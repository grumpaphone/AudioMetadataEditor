#!/usr/bin/env python3
import sys
import os
import re
import shutil  # For file copying operations
import json
import wav_metadata
import multiprocessing
from concurrent.futures import ThreadPoolExecutor
from functools import partial
from PyQt6.QtWidgets import (QApplication, QMainWindow, QTableWidget, 
                             QTableWidgetItem, QVBoxLayout, QWidget, QFileDialog,
                             QPushButton, QHBoxLayout, QMessageBox, QHeaderView,
                             QLineEdit, QLabel, QComboBox, QGroupBox, QFormLayout,
                             QDialog, QSpinBox, QSplitter, QFrame, QToolBar, 
                             QStatusBar, QStyle, QSizePolicy, QStyledItemDelegate,
                             QGridLayout, QListWidget, QCheckBox, QProgressDialog,
                             QMenu, QScrollArea, QStackedWidget, QListWidgetItem,
                             QTextEdit)
from PyQt6.QtCore import Qt, QMimeData, QSortFilterProxyModel, QSize, QMargins, QPropertyAnimation, QEasingCurve, QTimer, QRect, pyqtProperty, QThread, pyqtSignal
from PyQt6.QtGui import QPalette, QColor, QIcon, QFont, QPainter, QBrush, QPen, QPainterPath, QPixmap, QAction, QKeySequence, QShortcut
from PyQt6.QtSvg import QSvgRenderer
import threading
import csv

# Undo/Redo Command framework
class UndoRedoCommand:
    """Base class for undo/redo commands"""
    
    def __init__(self, description):
        """Initialize with a description of what the command does"""
        self.description = description
    
    def execute(self):
        """Execute the command - to be overridden by subclasses"""
        # This method should perform the actual operation
        # and return True on success, False on failure
        return True
    
    def undo(self):
        """Undo the command - to be overridden by subclasses"""
        # This method should undo the operation performed by execute()
        # and return True on success, False on failure
        return True
    
    def redo(self):
        """Redo the command (typically the same as execute)"""
        # By default, redo is the same as execute
        # Subclasses can override if needed
        return self.execute()

class MetadataEditCommand(UndoRedoCommand):
    """Command to edit metadata in a WAV file"""
    
    def __init__(self, editor, file_index, field, old_value, new_value):
        """Initialize with file index and metadata changes"""
        super().__init__(f"Edit {field}")
        
        self.editor = editor
        self.file_index = file_index
        self.field = field
        self.old_value = old_value
        self.new_value = new_value
    
    def execute(self):
        """Execute the metadata change"""
        try:
            # Update the metadata in memory
            file_path, metadata = self.editor.all_files[self.file_index]
            metadata[self.field] = self.new_value
            self.editor.all_files[self.file_index] = (file_path, metadata)
            
            # Update the UI
            self.editor.update_table_cell(self.file_index, self.field, self.new_value)
            
            # Mark changes as pending for save
            self.editor.changes_pending = True
            
            return True
        except Exception as e:
            print(f"Error executing metadata edit: {str(e)}")
            return False
    
    def undo(self):
        """Revert the metadata change"""
        try:
            # Revert metadata in memory
            file_path, metadata = self.editor.all_files[self.file_index]
            metadata[self.field] = self.old_value
            self.editor.all_files[self.file_index] = (file_path, metadata)
            
            # Update the UI
            self.editor.update_table_cell(self.file_index, self.field, self.old_value)
            
            # Still mark changes as pending since we're just reverting in memory
            self.editor.changes_pending = True
            
            # Show status message
            self.editor.status_label.setText(f"Undid edit to {self.field}")
            
            return True
        except Exception as e:
            print(f"Error undoing metadata edit: {str(e)}")
            return False

class FileRenameCommand(UndoRedoCommand):
    """Command to rename a file"""
    
    def __init__(self, editor, file_index, old_path, new_path):
        """Initialize with file paths and index"""
        # Get the simple filename for description
        old_name = os.path.basename(old_path)
        new_name = os.path.basename(new_path)
        super().__init__(f"Rename '{old_name}' to '{new_name}'")
        
        self.editor = editor
        self.file_index = file_index
        self.old_path = old_path
        self.new_path = new_path
    
    def execute(self):
        """Execute the rename operation"""
        # Check if the new file path already exists
        if os.path.exists(self.new_path) and self.new_path != self.old_path:
            # Show error message if file already exists
            QMessageBox.warning(
                self.editor, 
                "File Already Exists", 
                f"Cannot rename to '{os.path.basename(self.new_path)}': A file with this name already exists."
            )
            return False
            
        try:
            # Rename the file
            os.rename(self.old_path, self.new_path)
            
            # Update the metadata in memory
            file_path, metadata = self.editor.all_files[self.file_index]
            self.editor.all_files[self.file_index] = (self.new_path, metadata)
            
            # Update the filename in the table
            self.editor.update_filename_in_table(self.file_index, os.path.basename(self.new_path))
            
            # Update status message
            self.editor.status_label.setText(f"Renamed '{os.path.basename(self.old_path)}' to '{os.path.basename(self.new_path)}'")
            
            return True
        except Exception as e:
            # Show error message if rename fails
            QMessageBox.critical(
                self.editor, 
                "Rename Error", 
                f"Error renaming file: {str(e)}"
            )
            return False
    
    def undo(self):
        """Undo the rename operation"""
        # Check if the old file path already exists (would be overwritten)
        if os.path.exists(self.old_path) and self.old_path != self.new_path:
            QMessageBox.warning(
                self.editor, 
                "Cannot Undo", 
                f"Cannot undo rename: A file named '{os.path.basename(self.old_path)}' already exists."
            )
            return False
            
        try:
            # Rename back to the original
            os.rename(self.new_path, self.old_path)
            
            # Update the metadata in memory
            file_path, metadata = self.editor.all_files[self.file_index]
            self.editor.all_files[self.file_index] = (self.old_path, metadata)
            
            # Update the table
            self.editor.update_filename_in_table(self.file_index, self.old_filename)
            return True
            
        except Exception as e:
            print(f"Error undoing rename: {str(e)}")
            return False

class BatchCommand(UndoRedoCommand):
    """Command that groups multiple commands together as a single operation"""
    
    def __init__(self, description, commands):
        """Initialize with a list of commands"""
        super().__init__(description)
        self.commands = commands
    
    def execute(self):
        """Execute all commands in sequence"""
        success_count = 0
        failed_commands = []
        
        # Try to execute all commands
        for i, command in enumerate(self.commands):
            try:
                if command.execute():
                    success_count += 1
                else:
                    failed_commands.append((i, command))
            except Exception as e:
                print(f"Error executing command in batch: {str(e)}")
                failed_commands.append((i, command))
        
        # If any commands failed, try to undo the successful ones
        if failed_commands:
            print(f"Batch command partially failed: {len(failed_commands)} of {len(self.commands)} failed")
            
            # Undo the successful commands in reverse order
            for i in range(success_count - 1, -1, -1):
                try:
                    self.commands[i].undo()
                except Exception as e:
                    print(f"Error undoing command during rollback: {str(e)}")
            
            return False
        
        return True
    
    def undo(self):
        """Undo all commands in reverse order"""
        success_count = 0
        failed_commands = []
        
        # Undo commands in reverse order
        for i in range(len(self.commands) - 1, -1, -1):
            try:
                if self.commands[i].undo():
                    success_count += 1
                else:
                    failed_commands.append((i, self.commands[i]))
            except Exception as e:
                print(f"Error undoing command in batch: {str(e)}")
                failed_commands.append((i, self.commands[i]))
        
        return len(failed_commands) == 0
    
    def redo(self):
        """Redo all commands in sequence"""
        return self.execute()

class UndoRedoStack:
    """Stack to manage undo and redo operations"""
    
    def __init__(self, max_size=50):
        self.undo_stack = []
        self.redo_stack = []
        self.max_size = max_size
    
    def push(self, command):
        """Push a command onto the stack and execute it"""
        try:
            # Execute the command
            command.execute()
            
            # Add to undo stack
            self.undo_stack.append(command)
            
            # Clear the redo stack when a new command is added
            self.redo_stack.clear()
            
            # Limit the stack size
            if len(self.undo_stack) > self.max_size:
                self.undo_stack.pop(0)
                
            return True
        except Exception as e:
            print(f"Error executing command: {str(e)}")
            return False
    
    def undo(self):
        """Undo the last command"""
        if not self.undo_stack:
            return False
            
        try:
            # Pop the last command from the undo stack
            command = self.undo_stack.pop()
            
            # Undo the command
            command.undo()
            
            # Add to redo stack
            self.redo_stack.append(command)
            
            return True
        except Exception as e:
            print(f"Error undoing command: {str(e)}")
            return False
    
    def redo(self):
        """Redo the last undone command"""
        if not self.redo_stack:
            return False
            
        try:
            # Pop the last command from the redo stack
            command = self.redo_stack.pop()
            
            # Redo the command
            command.redo()
            
            # Add back to undo stack
            self.undo_stack.append(command)
            
            return True
        except Exception as e:
            print(f"Error redoing command: {str(e)}")
            return False
    
    def can_undo(self):
        """Check if there are commands to undo"""
        return len(self.undo_stack) > 0
    
    def can_redo(self):
        """Check if there are commands to redo"""
        return len(self.redo_stack) > 0
    
    def command_to_undo(self):
        """Get the command that would be undone next"""
        if not self.undo_stack:
            return None
        return self.undo_stack[-1]
    
    def command_to_redo(self):
        """Get the command that would be redone next"""
        if not self.redo_stack:
            return None
        return self.redo_stack[-1]
    
    def clear(self):
        """Clear both undo and redo stacks"""
        self.undo_stack.clear()
        self.redo_stack.clear()

class MacStyleDelegate(QStyledItemDelegate):
    """Custom delegate for macOS style table items"""
    def paint(self, painter, option, index):
        # Save painter state
        painter.save()
        
        # Draw background
        if option.state & QStyle.StateFlag.State_Selected:
            painter.fillRect(option.rect, QColor("#E0F2FF"))  # Light blue for selection
        elif index.row() % 2 == 0:  # Use index.row() instead of option.row
            painter.fillRect(option.rect, QColor("#FAFAFA"))  # Very light gray for alternating
        else:
            painter.fillRect(option.rect, QColor("#FFFFFF"))  # White
        
        # Draw text with proper padding
        text_rect = option.rect.adjusted(12, 6, -12, -6)  # Add padding
        
        # Set text color
        if option.state & QStyle.StateFlag.State_Selected:
            painter.setPen(QColor("#000000"))  # Black text on selection
        else:
            painter.setPen(QColor("#000000"))  # Black text normally
            
        painter.drawText(text_rect, Qt.AlignmentFlag.AlignLeft | Qt.AlignmentFlag.AlignVCenter, index.data())
        
        # Restore painter state
        painter.restore()


class AnimatedPushButton(QPushButton):
    """Custom button with click animation"""
    def __init__(self, text="", parent=None):
        super().__init__(text, parent)
        # Initialize attributes first
        self._normal_color = QColor(245, 236, 220, 153)  # 60% opacity
        self._hover_color = QColor(232, 223, 208, 204)   # 80% opacity
        self._click_color = QColor(224, 216, 201, 230)   # 90% opacity
        self._current_color = self._normal_color
        
        # Then create the animation
        self._animation = QPropertyAnimation(self, b"background_color")
        self._animation.setDuration(150)
        self.setStyleSheet(f"background-color: {self._normal_color.name()}")
        
    def get_background_color(self):
        return self._current_color
        
    def set_background_color(self, color):
        if self._current_color != color:
            self._current_color = color
            self.setStyleSheet(f"background-color: {color.name()}")
            
    background_color = pyqtProperty(QColor, get_background_color, set_background_color)
    
    def enterEvent(self, event):
        self._animation.stop()
        self._animation.setStartValue(self._current_color)
        self._animation.setEndValue(self._hover_color)
        self._animation.start()
        super().enterEvent(event)
        
    def leaveEvent(self, event):
        self._animation.stop()
        self._animation.setStartValue(self._current_color)
        self._animation.setEndValue(self._normal_color)
        self._animation.start()
        super().leaveEvent(event)
        
    def mousePressEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton:
            self._animation.stop()
            self._animation.setStartValue(self._current_color)
            self._animation.setEndValue(self._click_color)
            self._animation.start()
        super().mousePressEvent(event)
        
    def mouseReleaseEvent(self, event):
        if event.button() == Qt.MouseButton.LeftButton:
            self._animation.stop()
            self._animation.setStartValue(self._current_color)
            self._animation.setEndValue(self._hover_color if self.underMouse() else self._normal_color)
            self._animation.start()
        super().mouseReleaseEvent(event)


class AnimatedPrimaryButton(AnimatedPushButton):
    """Primary styled animated button"""
    def __init__(self, text="", parent=None):
        super().__init__(text, parent)
        # Use primary colors
        self._normal_color = QColor(196, 181, 159, 230)  # 90% opacity
        self._hover_color = QColor(181, 167, 144, 242)   # 95% opacity
        self._click_color = QColor(166, 152, 127, 255)   # 100% opacity
        self._current_color = self._normal_color
        self.setStyleSheet(f"background-color: {self._normal_color.name()}; color: white; border: none;")
        self.setCursor(Qt.CursorShape.PointingHandCursor)


class FileLoadWorker(QThread):
    progress = pyqtSignal(int, int, str)
    finished = pyqtSignal(list)
    
    def __init__(self, file_paths):
        super().__init__()
        self.file_paths = file_paths
        
    def run(self):
        results = []
        total_files = len(self.file_paths)
        
        # Create a pool of workers for parallel processing
        cpu_count = max(1, multiprocessing.cpu_count() - 1)  # Leave one CPU free
        
        # Process files in batches to avoid memory issues
        batch_size = 50
        for i in range(0, total_files, batch_size):
            if self.isInterruptionRequested():
                break
                
            batch = self.file_paths[i:i+batch_size]
            
            with ThreadPoolExecutor(max_workers=cpu_count) as executor:
                # Create a list to store futures and their corresponding file paths
                futures_with_paths = []
                for file_path in batch:
                    future = executor.submit(self.safe_read_metadata, file_path)
                    futures_with_paths.append((future, file_path))
                
                for j, (future, file_path) in enumerate(futures_with_paths):
                    if self.isInterruptionRequested():
                        break
                        
                    current_idx = i + j
                    try:
                        # Get the metadata result from the future (or empty metadata if it failed)
                        metadata = future.result()
                        # Add filename to metadata
                        metadata["Filename"] = os.path.basename(file_path)
                        results.append((file_path, metadata))
                    except Exception as e:
                        # If an exception occurred during metadata reading, create empty metadata
                        print(f"Error reading metadata for {file_path}: {str(e)}")
                        metadata = {
                            "Filename": os.path.basename(file_path),
                            "Show": "",
                            "Scene": "",
                            "Take": "",
                            "Category": "",
                            "Subcategory": "",
                            "Slate": "",
                            "ixmlNote": "",
                            "ixmlWildtrack": "",
                            "ixmlCircled": "",
                            "File Path": file_path,
                            "Error": str(e)
                        }
                        results.append((file_path, metadata))
                    
                    # Emit progress
                    self.progress.emit(current_idx + 1, total_files, os.path.basename(file_path))
                    
                    # Check if we should stop
                    if self.isInterruptionRequested():
                        break
            
            if self.isInterruptionRequested():
                break
                
        self.finished.emit(results)
        
    def safe_read_metadata(self, file_path):
        """Safely read metadata with proper error handling"""
        try:
            return wav_metadata.read_wav_metadata(file_path)
        except Exception as e:
            # Log the error and return empty metadata
            print(f"Error reading metadata: {str(e)}")
            # Create empty metadata dictionary
            return {
                "Show": "",
                "Scene": "",
                "Take": "",
                "Category": "",
                "Subcategory": "",
                "Slate": "",
                "ixmlNote": "",
                "ixmlWildtrack": "",
                "ixmlCircled": "",
                "File Path": file_path,
                "Error": str(e)
            }


class AudioMetadataEditor(QMainWindow):
    def __init__(self):
        super().__init__()
        self.setWindowTitle("Audio Metadata Editor")
        self.setMinimumSize(900, 600)
        self.resize(1100, 700)
        
        # Configure for frameless window
        self.setWindowFlags(Qt.WindowType.FramelessWindowHint)
        self.setAttribute(Qt.WidgetAttribute.WA_TranslucentBackground)
        
        # Set the application style
        self.apply_stylesheet()
        
        # Setup UI
        self.central_widget = QWidget()
        self.central_widget.setObjectName("central_widget")
        self.central_widget.setStyleSheet("""
            #central_widget {
                background-color: rgba(245, 236, 220, 0.92);
                border-radius: 10px;
            }
        """)
        self.setCentralWidget(self.central_widget)
        
        # Initialize undo/redo stack
        self.undo_redo_stack = UndoRedoStack()
        
        # Main layout with reduced margins
        main_layout = QVBoxLayout(self.central_widget)
        main_layout.setContentsMargins(10, 8, 10, 8)  # Reduced margins
        main_layout.setSpacing(8)  # Reduced spacing
        
        # Add integrated title bar with window controls and app controls
        self.create_integrated_title_bar(main_layout)
        
        # Set up keyboard shortcuts
        self.setup_shortcuts()
        
        # Enable drag and drop
        self.setAcceptDrops(True)
        
        # Create the main splitter for content and side panel
        self.main_splitter = QSplitter(Qt.Orientation.Horizontal)
        self.main_splitter.setHandleWidth(1)
        self.main_splitter.setChildrenCollapsible(False)
        
        # Main content widget
        self.content_widget = QWidget()
        self.content_layout = QVBoxLayout(self.content_widget)
        self.content_layout.setContentsMargins(0, 0, 0, 0)
        self.content_layout.setSpacing(15)
        
        # Create mirror panel (hidden by default)
        self.mirror_panel = MirrorPanel(self)
        self.mirror_panel.setVisible(False)  # Start hidden
        self.mirror_panel.setMinimumWidth(350)
        self.mirror_panel.setMaximumWidth(400)
        
        # Add widgets to splitter
        self.main_splitter.addWidget(self.content_widget)
        self.main_splitter.addWidget(self.mirror_panel)
        
        # Set splitter sizes to show content and hide panel initially
        self.main_splitter.setSizes([1, 0])
        
        # Add splitter to main layout
        main_layout.addWidget(self.main_splitter)
        
        # Search and table container
        content_container = QWidget()
        content_container.setProperty("class", "content-container")
        content_container.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        content_layout = QVBoxLayout(content_container)
        content_layout.setContentsMargins(0, 0, 0, 0)
        
        # Table container with macOS-style rounded corners and shadow
        table_container = QWidget()
        table_container.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        table_container.setProperty("class", "table-container")
        table_layout = QVBoxLayout(table_container)
        table_layout.setContentsMargins(0, 0, 0, 0)
        
        # Metadata table
        self.metadata_table = QTableWidget(0, 11)  # rows, cols - increased to 11 for Filename and File Path
        self.metadata_table.setHorizontalHeaderLabels([
            "Filename", "Show", "Scene", "Take", "Category", 
            "Subcategory", "Slate", "ixmlNote", "ixmlWildtrack", "ixmlCircled", "File Path"
        ])
        self.metadata_table.setAlternatingRowColors(True)
        self.metadata_table.setSelectionBehavior(QTableWidget.SelectionBehavior.SelectRows)
        self.metadata_table.setEditTriggers(QTableWidget.EditTrigger.DoubleClicked | QTableWidget.EditTrigger.SelectedClicked)
        self.metadata_table.verticalHeader().setVisible(False)
        
        # Set horizontal header properties
        header = self.metadata_table.horizontalHeader()
        
        # Make all columns resizable (Interactive mode)
        for col in range(self.metadata_table.columnCount()):
            header.setSectionResizeMode(col, QHeaderView.ResizeMode.Interactive)
            
        # Initially size columns to their content
        self.metadata_table.resizeColumnsToContents()
        
        # Set minimum size for all columns
        header.setMinimumSectionSize(100)
        
        # Make filename and file path columns wider initially
        self.metadata_table.setColumnWidth(0, 200)  # Filename column
        self.metadata_table.setColumnWidth(10, 250)  # File Path column
        
        # Set delegate for macOS-style appearance
        self.metadata_table.setItemDelegate(MacStyleDelegate())
        
        # Connect signals
        self.metadata_table.itemChanged.connect(self.update_metadata)
        self.metadata_table.itemSelectionChanged.connect(self.on_selection_changed)
        
        # Set up right-click context menu
        self.setup_table_context_menu()
        
        table_layout.addWidget(self.metadata_table)
        
        content_layout.addWidget(table_container, 1)  # 1 = stretch factor
        
        self.content_layout.addWidget(content_container, 1)  # 1 = stretch factor
        
        # Status bar at the bottom - subtle, Apple-style
        self.status_label = QLabel("Ready")
        self.status_label.setProperty("class", "status-label")
        self.content_layout.addWidget(self.status_label)
        
        # Data storage
        self.all_files = []
        self.filtered_rows = []
        self.changes_pending = False
        
        # Enable animations in the application
        self.animations_enabled = True
        
        # For debounced search
        self.search_timer = QTimer()
        self.search_timer.setSingleShot(True)
        self.search_timer.timeout.connect(self.filter_table)
        
        # File load worker
        self.file_load_worker = None
        self.progress_dialog = None
    
    def apply_stylesheet(self):
        """Apply a modern macOS-inspired stylesheet with translucent elements"""
        # Set system font (SF Pro-like) - using system font family instead of specific name
        if sys.platform == "darwin":  # macOS
            app_font = QFont(".AppleSystemUIFont", 12)  # Smaller font size
        else:  # Windows/Linux
            app_font = QFont("Segoe UI", 12)  # Smaller font size
        QApplication.setFont(app_font)
        
        # Create and apply stylesheet
        stylesheet = """
        /* Main window - higher alpha for frostier effect */
        QMainWindow {
            background-color: rgba(245, 236, 220, 0.92);
            border: none;
            border-radius: 10px;
        }
        
        /* Content container */
        .content-container {
            background-color: rgba(245, 236, 220, 0.85);
            border-radius: 10px;
        }
        
        /* Icon button style */
        .icon-button {
            background-color: rgba(245, 236, 220, 0.75);
            border: none;
            border-radius: 8px;
            padding: 8px;
        }
        
        .icon-button:hover {
            background-color: rgba(232, 223, 208, 0.85);
        }
        
        .icon-button:pressed {
            background-color: rgba(224, 216, 201, 0.92);
        }
        
        /* Action button style */
        .action-button {
            background-color: rgba(245, 236, 220, 0.75);
            color: #000000;
            border: none;
            border-radius: 8px;
            font-weight: 500;
            font-size: 13px;
        }
        
        .action-button:hover {
            background-color: rgba(232, 223, 208, 0.85);
        }
        
        .action-button:pressed {
            background-color: rgba(224, 216, 201, 0.92);
        }
        
        /* Primary button style */
        .action-button.primary {
            background-color: rgba(196, 181, 159, 0.92);
            color: white;
            border: none;
        }
        
        .action-button.primary:hover {
            background-color: rgba(181, 167, 144, 0.95);
        }
        
        .action-button.primary:pressed {
            background-color: rgba(166, 152, 127, 1.0);
        }
        
        /* QLineEdit styling */
        QLineEdit {
            border: 1px solid rgba(224, 216, 201, 0.8);
            border-radius: 6px;
            padding: 4px 6px;
            background-color: rgba(255, 255, 255, 0.85);
            selection-background-color: rgba(196, 181, 159, 0.8);
            selection-color: white;
        }
        
        QLineEdit:focus {
            border: 1px solid rgba(196, 181, 159, 0.92);
            background-color: rgba(255, 255, 255, 0.95);
        }
        
        /* Labels */
        QLabel {
            color: #000000;
            font-size: 13px;
        }
        
        /* Title label larger */
        #title_label {
            font-size: 18px;
            font-weight: 500;
            color: #000000;
        }
        
        /* Table styling */
        QTableWidget {
            border: none;
            background-color: rgba(255, 255, 255, 0.9);
            selection-background-color: rgba(232, 223, 208, 0.85);
            alternate-background-color: rgba(249, 245, 239, 0.75);
            gridline-color: rgba(232, 223, 208, 0.8);
        }
        
        QHeaderView::section {
            background-color: rgba(255, 255, 255, 0.85);
            padding: 6px;
            border: none;
            border-bottom: 1px solid rgba(224, 216, 201, 0.8);
            font-weight: 500;
            color: #333333;
        }
        
        /* Status bar */
        .status-label {
            color: #666666;
            font-size: 12px;
            padding: 4px;
        }
        
        /* Dialog styling */
        QDialog {
            background-color: rgba(245, 236, 220, 0.92);
            border-radius: 8px;
        }
        
        /* Dropdown/ComboBox styling */
        QComboBox {
            border: 1px solid rgba(208, 200, 185, 0.8);
            border-radius: 6px;
            padding: 5px;
            background-color: rgba(255, 255, 255, 0.85);
            color: #333333;
            selection-background-color: rgba(196, 181, 159, 0.8);
            selection-color: white;
        }
        
        QComboBox::drop-down {
            subcontrol-origin: padding;
            subcontrol-position: top right;
            width: 20px;
            border-left: 1px solid rgba(208, 200, 185, 0.8);
            border-top-right-radius: 4px;
            border-bottom-right-radius: 4px;
        }
        
        QComboBox::down-arrow {
            width: 12px;
            height: 12px;
            image: url(:/icons/dropdown_arrow.png);
        }
        
        QComboBox QAbstractItemView {
            background-color: rgba(255, 255, 255, 0.95);
            border: 1px solid rgba(208, 200, 185, 0.8);
            color: #333333;
            selection-background-color: rgba(196, 181, 159, 0.8);
            selection-color: white;
        }
        
        /* Line Edit and ComboBox common styles */
        QLineEdit, QComboBox, QSpinBox {
            padding: 5px;
            border: 1px solid rgba(208, 200, 185, 0.8);
            border-radius: 4px;
            background-color: rgba(255, 255, 255, 0.85);
            color: #333333;
        }
        
        /* Splitter styling */
        QSplitter::handle {
            background-color: rgba(224, 216, 201, 0.7);
        }
        
        /* Menu styling */
        QMenu {
            background-color: rgba(245, 236, 220, 0.95);
            border: 1px solid rgba(224, 216, 201, 0.8);
            border-radius: 6px;
            padding: 4px;
        }
        
        QMenu::item {
            padding: 4px 20px 4px 6px;
            border-radius: 4px;
            color: #333333;
        }
        
        QMenu::item:selected {
            background-color: rgba(232, 223, 208, 0.85);
        }
        
        /* QScrollBar styling */
        QScrollBar:vertical {
            border: none;
            background: rgba(245, 236, 220, 0.4);
            width: 10px;
            margin: 0px;
            border-radius: 5px;
        }
        
        QScrollBar::handle:vertical {
            background: rgba(196, 181, 159, 0.8);
            min-height: 20px;
            border-radius: 5px;
        }
        
        QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
            border: none;
            background: none;
            height: 0px;
        }
        
        QScrollBar:horizontal {
            border: none;
            background: rgba(245, 236, 220, 0.4);
            height: 10px;
            margin: 0px;
            border-radius: 5px;
        }
        
        QScrollBar::handle:horizontal {
            background: rgba(196, 181, 159, 0.8);
            min-width: 20px;
            border-radius: 5px;
        }
        
        QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {
            border: none;
            background: none;
            width: 0px;
        }
        """
        self.setStyleSheet(stylesheet)
    
    def on_search_changed(self):
        """Debounced search that triggers after user stops typing."""
        self.search_timer.stop()
        self.search_timer.start(300)  # 300ms debounce

    def on_selection_changed(self):
        """Update the mirror panel when selection changes"""
        selected_rows = self.get_selected_actual_rows()
        if self.mirror_panel.isVisible() and selected_rows:
            self.mirror_panel.set_selected_rows(selected_rows)
            self.mirror_panel.update_selected_count()
    
    def setup_table_context_menu(self):
        """Set up context menu for the metadata table"""
        self.metadata_table.setContextMenuPolicy(Qt.ContextMenuPolicy.CustomContextMenu)
        self.metadata_table.customContextMenuRequested.connect(self.show_table_context_menu)
    
    def show_table_context_menu(self, position):
        """Show context menu for the metadata table"""
        # Get the selected rows
        selected_rows = self.get_selected_actual_rows()
        if not selected_rows:
            return
            
        # Create menu
        menu = QMenu(self)
        
        # Get row and column under cursor
        item = self.metadata_table.itemAt(position)
        if not item:
            return
            
        row = item.row()
        col = item.column()
        
        # Options for filename column
        if col == 0:
            # Add rename action
            rename_action = QAction("Edit Filename", self)
            rename_action.triggered.connect(lambda: self.metadata_table.editItem(item))
            menu.addAction(rename_action)
            
            # Add batch rename action if multiple rows are selected
            if len(selected_rows) > 1:
                batch_rename_action = QAction("Batch Rename...", self)
                batch_rename_action.triggered.connect(lambda: self.show_batch_rename_dialog(selected_rows))
                menu.addAction(batch_rename_action)
            
            # Add revert action if there's just one selected row
            if len(selected_rows) == 1:
                # Get actual row in all_files
                actual_row = self.filtered_rows[row]
                file_path = self.all_files[actual_row][0]
                orig_filename = os.path.basename(file_path)
                current_filename = item.text()
                
                if current_filename != orig_filename:
                    revert_action = QAction("Revert Filename", self)
                    revert_action.triggered.connect(lambda: self.revert_filename(row))
                    menu.addAction(revert_action)
        
        # Options for other columns
        else:
            # Add edit action
            edit_action = QAction("Edit Cell", self)
            edit_action.triggered.connect(lambda: self.metadata_table.editItem(item))
            menu.addAction(edit_action)
            
            # Add copy action
            copy_action = QAction("Copy", self)
            copy_action.triggered.connect(lambda: QApplication.clipboard().setText(item.text()))
            menu.addAction(copy_action)
            
            # Add paste action
            if QApplication.clipboard().text():
                paste_action = QAction("Paste", self)
                paste_action.triggered.connect(lambda: self.paste_to_selected_cells(col))
                menu.addAction(paste_action)
        
        # Show the menu
        menu.exec(self.metadata_table.mapToGlobal(position))
    
    def show_batch_rename_dialog(self, selected_rows):
        """Show a dialog for batch renaming multiple files"""
        dialog = QDialog(self)
        dialog.setWindowTitle("Batch Rename Files")
        dialog.setMinimumWidth(500)
        dialog.setStyleSheet("""
            QDialog {
                background-color: rgba(245, 236, 220, 0.92);
                border-radius: 8px;
            }
        """)
        
        layout = QVBoxLayout(dialog)
        layout.setContentsMargins(16, 16, 16, 16)
        
        # Instructions
        instructions = QLabel(
            "Enter a pattern for renaming files. Use the following placeholders:\n"
            "- {original}: Original filename (without extension)\n"
            "- {num}: Sequential number\n"
            "- {show}, {scene}, {take}, etc.: Metadata fields\n\n"
            "Example: {show}_{scene}_{category}_{num}"
        )
        instructions.setWordWrap(True)
        layout.addWidget(instructions)
        
        # Pattern input
        pattern_layout = QHBoxLayout()
        pattern_label = QLabel("Pattern:")
        pattern_input = QLineEdit()
        pattern_input.setPlaceholderText("Enter rename pattern...")
        pattern_input.setText("{original}")
        
        pattern_layout.addWidget(pattern_label)
        pattern_layout.addWidget(pattern_input, 1)
        layout.addLayout(pattern_layout)
        
        # Start number input
        start_num_layout = QHBoxLayout()
        start_num_label = QLabel("Start Number:")
        start_num_input = QLineEdit()
        start_num_input.setText("1")
        start_num_input.setFixedWidth(80)
        
        # Padding input
        padding_label = QLabel("Padding:")
        padding_input = QLineEdit()
        padding_input.setText("2")
        padding_input.setFixedWidth(80)
        padding_input.setToolTip("Number of digits to pad with zeros (e.g. 2 = 01, 02, etc.)")
        
        start_num_layout.addWidget(start_num_label)
        start_num_layout.addWidget(start_num_input)
        start_num_layout.addWidget(padding_label)
        start_num_layout.addWidget(padding_input)
        start_num_layout.addStretch()
        layout.addLayout(start_num_layout)
        
        # Preview section
        preview_group = QGroupBox("Preview")
        preview_layout = QVBoxLayout(preview_group)
        
        preview_list = QListWidget()
        preview_layout.addWidget(preview_list)
        
        layout.addWidget(preview_group)
        
        # Update preview function
        def update_preview():
            try:
                pattern = pattern_input.text()
                start_num = int(start_num_input.text())
                padding = int(padding_input.text())
                
                preview_list.clear()
                
                for i, idx in enumerate(selected_rows):
                    file_path, metadata = self.all_files[idx]
                    original = os.path.splitext(os.path.basename(file_path))[0]
                    extension = os.path.splitext(file_path)[1]
                    
                    # Prepare replacement dict
                    replacements = {
                        'original': original,
                        'num': str(start_num + i).zfill(padding)
                    }
                    
                    # Add metadata fields
                    for key, value in metadata.items():
                        if isinstance(value, str):
                            replacements[key.lower()] = value
                    
                    # Format the new filename
                    try:
                        new_name = pattern.format(**replacements) + extension
                        preview_list.addItem(f"{original}{extension} â†’ {new_name}")
                    except KeyError as e:
                        preview_list.addItem(f"Error: {str(e)} not found in metadata")
                
            except ValueError:
                preview_list.clear()
                preview_list.addItem("Invalid number input")
        
        # Connect signals
        pattern_input.textChanged.connect(update_preview)
        start_num_input.textChanged.connect(update_preview)
        padding_input.textChanged.connect(update_preview)
        
        # Buttons
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        cancel_button = QPushButton("Cancel")
        cancel_button.clicked.connect(dialog.reject)
        
        rename_button = QPushButton("Rename")
        rename_button.clicked.connect(lambda: self.batch_rename_files(
            selected_rows, 
            pattern_input.text(), 
            int(start_num_input.text()), 
            int(padding_input.text()), 
            dialog
        ))
        rename_button.setProperty("class", "primary")
        
        button_layout.addWidget(cancel_button)
        button_layout.addWidget(rename_button)
        
        layout.addLayout(button_layout)
        
        # Initial preview
        update_preview()
        
        # Show dialog
        dialog.exec()
    
    def batch_rename_files(self, selected_rows, pattern, start_num, padding, dialog):
        """Perform batch renaming of files"""
        # First check for file name collisions
        new_paths = []
        rename_commands = []
        
        # Set up progress dialog for checking
        progress = QProgressDialog("Checking filenames...", "Cancel", 0, len(selected_rows), self)
        progress.setWindowModality(Qt.WindowModality.WindowModal)
        progress.setMinimumDuration(500)  # Only show if operation takes longer than 500ms
        
        for i, idx in enumerate(selected_rows):
            if progress.wasCanceled():
                dialog.reject()
                return
                
            progress.setValue(i)
            QApplication.processEvents()
            
            file_path, metadata = self.all_files[idx]
            original = os.path.splitext(os.path.basename(file_path))[0]
            extension = os.path.splitext(file_path)[1]
            directory = os.path.dirname(file_path)
            
            # Prepare replacement dict
            replacements = {
                'original': original,
                'num': str(start_num + i).zfill(padding)
            }
            
            # Add metadata fields
            for key, value in metadata.items():
                if isinstance(value, str):
                    replacements[key.lower()] = value
            
            # Format the new filename
            try:
                new_name = pattern.format(**replacements) + extension
                new_path = os.path.join(directory, new_name)
                
                # Skip if the file is being renamed to itself
                if new_path == file_path:
                    continue
                    
                # Check for collisions
                if new_path in new_paths:
                    QMessageBox.warning(
                        self, 
                        "Naming Conflict", 
                        f"The pattern would result in duplicate filename: {new_name}\nBatch rename canceled."
                    )
                    dialog.reject()
                    return
                
                # Check if the file already exists on disk
                if os.path.exists(new_path) and new_path != file_path:
                    QMessageBox.warning(
                        self, 
                        "File Already Exists", 
                        f"Cannot rename to '{new_name}': A file with this name already exists in the directory."
                    )
                    dialog.reject()
                    return
                    
                new_paths.append(new_path)
                
                # Create rename command
                command = FileRenameCommand(self, idx, file_path, new_path)
                rename_commands.append(command)
                
            except KeyError as e:
                QMessageBox.warning(
                    self, 
                    "Pattern Error", 
                    f"Error in pattern: {str(e)} not found in metadata\nBatch rename canceled."
                )
                dialog.reject()
                return
        
        # Close the progress dialog
        progress.setValue(len(selected_rows))
        
        # If no files to rename, just return
        if not rename_commands:
            self.status_label.setText("No files need to be renamed")
            dialog.accept()
            return
        
        # Create a batch command for the entire rename operation
        batch_command = BatchCommand(f"Batch Rename {len(rename_commands)} Files", rename_commands)
        if self.undo_redo_stack.push(batch_command):
            self.status_label.setText(f"Successfully renamed {len(rename_commands)} files")
            # Update undo/redo button states
            self.update_undo_redo_buttons()
            dialog.accept()
        else:
            self.status_label.setText("Failed to rename files")
            dialog.reject()
    
    def revert_filename(self, row):
        """Revert the filename at the given row to its original value"""
        if row < 0 or row >= self.metadata_table.rowCount():
            return
            
        # Get actual row in all_files
        actual_row = self.filtered_rows[row]
        file_path, _ = self.all_files[actual_row]
        orig_filename = os.path.basename(file_path)
        
        # Update the table
        self.metadata_table.blockSignals(True)
        self.metadata_table.item(row, 0).setText(orig_filename)
        self.metadata_table.blockSignals(False)
    
    def paste_to_selected_cells(self, column):
        """Paste clipboard content to all selected cells in the given column"""
        clipboard_text = QApplication.clipboard().text()
        if not clipboard_text:
            return
            
        # Get all selected items in the specified column
        ranges = self.metadata_table.selectedRanges()
        for selection_range in ranges:
            for row in range(selection_range.topRow(), selection_range.bottomRow() + 1):
                item = self.metadata_table.item(row, column)
                if item:
                    item.setText(clipboard_text)

    def dragEnterEvent(self, event):
        if event.mimeData().hasUrls():
            event.accept()
        else:
            event.ignore()
            
    def dropEvent(self, event):
        files = [u.toLocalFile() for u in event.mimeData().urls()]
        for file_path in files:
            if os.path.isdir(file_path):
                self.load_files_from_folder(file_path)
                
    def browse_folder(self):
        """Browse for a folder and load WAV files."""
        folder_path = QFileDialog.getExistingDirectory(self, "Select Folder")
        if folder_path:
            self.load_files_from_folder(folder_path)
    
    def load_files_from_folder(self, folder_path):
        """Load WAV files from a folder with progress tracking."""
        import glob
        
        # Find all WAV files in the folder and subfolders
        self.status_label.setText("Finding WAV files...")
        QApplication.processEvents()
        wav_files = glob.glob(os.path.join(folder_path, "**", "*.wav"), recursive=True)
        
        if not wav_files:
            QMessageBox.warning(self, "No WAV Files", f"No WAV files found in {folder_path}")
            return
        
        # Set up a progress dialog
        self.progress_dialog = QProgressDialog("Loading WAV files...", "Cancel", 0, len(wav_files), self)
        self.progress_dialog.setWindowModality(Qt.WindowModality.WindowModal)
        self.progress_dialog.setMinimumDuration(500)  # Only show if operation takes longer than 500ms
        
        # Clear existing data first
        self.metadata_table.setRowCount(0)
        self.all_files = []
        
        # Create and start the worker thread
        self.file_load_worker = FileLoadWorker(wav_files)
        self.file_load_worker.progress.connect(self.update_load_progress)
        self.file_load_worker.finished.connect(self.on_files_loaded)
        self.progress_dialog.canceled.connect(self.cancel_file_loading)
        self.file_load_worker.start()
    
    def update_load_progress(self, current, total, filename):
        """Update the progress dialog"""
        if self.progress_dialog is None:
            return
        
            self.progress_dialog.setValue(current)
            self.progress_dialog.setLabelText(f"Loading {current}/{total}: {filename}")
            QApplication.processEvents()
    
    def cancel_file_loading(self):
        """Cancel the file loading process"""
        if self.file_load_worker and self.file_load_worker.isRunning():
            self.file_load_worker.requestInterruption()
            self.file_load_worker.wait()
    
    def on_files_loaded(self, results):
        """Handle completed file loading"""
        self.all_files = results
        
        # Close the progress dialog
        if self.progress_dialog:
            self.progress_dialog.close()
            self.progress_dialog = None
        
        # Check for files with errors
        files_with_errors = []
        for file_path, metadata in results:
            if metadata.get("Error"):
                files_with_errors.append((file_path, metadata.get("Error", "Unknown error")))
        
        # Update the UI
        self.update_table()
        
        # Show status message
        if files_with_errors:
            error_count = len(files_with_errors)
            total_count = len(results)
            self.status_label.setText(f"Loaded {total_count - error_count} of {total_count} WAV files ({error_count} with errors)")
            
            # Show a notification about errors
            if error_count <= 5:
                # If few errors, show details
                error_msg = "The following files had errors:\n"
                for file_path, error in files_with_errors:
                    error_msg += f"â€¢ {os.path.basename(file_path)}: {error}\n"
                QMessageBox.warning(self, "Loading Errors", error_msg)
            else:
                # If many errors, show summary
                QMessageBox.warning(
                    self, 
                    "Loading Errors", 
                    f"{error_count} of {total_count} files had errors during loading.\n"
                    "Files with errors will be shown in the table but may have incomplete metadata."
                )
        else:
            self.status_label.setText(f"Loaded {len(self.all_files)} WAV files")
    
    def update_table(self):
        """Update the table with current metadata (optimized)."""
        # Disconnect the signal temporarily to avoid triggering updates
        self.metadata_table.blockSignals(True)
        
        # Clear the table
        self.metadata_table.setRowCount(0)
        
        # Reset filtered rows
        self.filtered_rows = list(range(len(self.all_files)))
        
        # Apply current filter
        self.filter_table()
        
        # Reconnect the signal
        self.metadata_table.blockSignals(False)
    
    def filter_table(self):
        """Filter the table based on search term (optimized)."""
        search_term = self.search_input.text().lower()
        search_field = self.current_search_field
        
        # Disconnect signals temporarily and disable updates
        self.metadata_table.blockSignals(True)
        self.metadata_table.setUpdatesEnabled(False)
        
        # Clear the table
        self.metadata_table.setRowCount(0)
        
        # First pass: identify matching rows
        self.filtered_rows = []
        
        # Fast path for no filter
        if not search_term:
            self.filtered_rows = list(range(len(self.all_files)))
        else:
            # Use different search strategies based on the field
            if search_field == "All Fields":
                # Search in all fields including filename
                for i, (file_path, metadata) in enumerate(self.all_files):
                    filename = os.path.basename(file_path)
                    if (search_term in filename.lower() or 
                        any(search_term in str(value).lower() for value in metadata.values())):
                        self.filtered_rows.append(i)
            elif search_field == "Filename":
                # Search in filename only
                for i, (file_path, _) in enumerate(self.all_files):
                    filename = os.path.basename(file_path)
                    if search_term in filename.lower():
                        self.filtered_rows.append(i)
            else:
                # Search in the specified field
                for i, (_, metadata) in enumerate(self.all_files):
                    if search_term in str(metadata.get(search_field, "")).lower():
                        self.filtered_rows.append(i)
        
        # Second pass: batch populate table
        if self.filtered_rows:
            # Pre-allocate rows for better performance
            self.metadata_table.setRowCount(len(self.filtered_rows))
            
            # Create all table items at once
            table_items = []
            for table_row, file_idx in enumerate(self.filtered_rows):
                file_path, metadata = self.all_files[file_idx]
                
                # Get the filename from the file_path
                filename = os.path.basename(file_path)
                
                # Create a row of items
                row_items = [QTableWidgetItem(filename)]
                
                # Add metadata fields
                for key in ["Show", "Scene", "Take", "Category", 
                          "Subcategory", "Slate", "ixmlNote", "ixmlWildtrack", "ixmlCircled"]:
                    row_items.append(QTableWidgetItem(metadata.get(key, "")))
                
                # Add file path
                file_path_item = QTableWidgetItem(file_path)
                file_path_item.setFlags(file_path_item.flags() & ~Qt.ItemFlag.ItemIsEditable)  # Make non-editable
                row_items.append(file_path_item)
                
                # Make filename editable - removing this line
                # row_items[0].setFlags(row_items[0].flags() & ~Qt.ItemFlag.ItemIsEditable)
                
                table_items.append(row_items)
            
            # Add all items to the table at once
            for row, row_items in enumerate(table_items):
                for col, item in enumerate(row_items):
                    self.metadata_table.setItem(row, col, item)
        
        # Re-enable updates and signals
        self.metadata_table.setUpdatesEnabled(True)
        self.metadata_table.blockSignals(False)
        
        # Update status message
        if len(self.filtered_rows) == len(self.all_files):
            self.status_label.setText(f"Showing all {len(self.all_files)} files")
        else:
            self.status_label.setText(f"Showing {len(self.filtered_rows)} of {len(self.all_files)} files")
    
    def update_table_cell(self, file_index, field, value):
        """Update a specific cell in the table based on file index and field"""
        # Find the table row that corresponds to the file index
        for table_row, filtered_idx in enumerate(self.filtered_rows):
            if filtered_idx == file_index:
                # Determine the column based on the field
                metadata_keys = ["Show", "Scene", "Take", "Category", 
                             "Subcategory", "Slate", "ixmlNote", "ixmlWildtrack", "ixmlCircled"]
                
                if field in metadata_keys:
                    col = metadata_keys.index(field) + 1  # +1 to account for filename column
                    
                    # Update the cell
                    self.metadata_table.blockSignals(True)
                    self.metadata_table.item(table_row, col).setText(value)
                    self.metadata_table.blockSignals(False)
                break
    
    def update_filename_in_table(self, file_index, new_filename):
        """Update the filename and file path in the table"""
        file_path, _ = self.all_files[file_index]
        
        # Find the table row that corresponds to the file index
        for table_row, filtered_idx in enumerate(self.filtered_rows):
            if filtered_idx == file_index:
                # Update the filename (column 0)
                self.metadata_table.blockSignals(True)
                self.metadata_table.item(table_row, 0).setText(new_filename)
                
                # Update the file path (column 10)
                self.metadata_table.item(table_row, 10).setText(file_path)
                self.metadata_table.blockSignals(False)
                break
    
    def update_metadata(self, item):
        """Update metadata when a cell is edited."""
        row = item.row()
        col = item.column()
        
        # Get the index in self.all_files
        if 0 <= row < len(self.filtered_rows):
            # Get the actual index in all_files from the filtered rows list
            actual_row = self.filtered_rows[row]
            file_path, metadata = self.all_files[actual_row]
            
            # Get the new value from the table
            new_value = item.text()
            
            if col == 0:  # Filename column
                old_filename = os.path.basename(file_path)
                if new_value != old_filename:
                    self.rename_file(actual_row, new_value)
            elif 1 <= col <= 9:  # Metadata columns
                # Map column indices to metadata keys
                               metadata_keys = ["Show", "Scene", "Take", "Category", 
                               "Subcategory", "Slate", "ixmlNote", "ixmlWildtrack", "ixmlCircled"]
                               
                               # Get the metadata key and old value
                               key = metadata_keys[col - 1]  # -1 to account for filename column
                               old_value = metadata.get(key, "")
                
                # Only update if the value has changed
                if new_value != old_value:
                    # Create and push the command to the stack
                    command = MetadataEditCommand(self, actual_row, key, old_value, new_value)
                    self.undo_redo_stack.push(command)
            
            # Mark that changes are pending
            self.changes_pending = True
            self.status_label.setText("Changes pending - press Save to apply")
    
    def rename_file(self, file_index, new_filename):
        """Rename the file at the given index with the new filename."""
        if file_index < 0 or file_index >= len(self.all_files):
            return False
            
        file_path, metadata = self.all_files[file_index]
        
        # Get directory and old filename
        directory = os.path.dirname(file_path)
        old_filename = os.path.basename(file_path)
        
        # Ensure the new filename has the same extension
        _, extension = os.path.splitext(old_filename)
        if not new_filename.endswith(extension):
            new_filename += extension
            
        # Create new file path
        new_file_path = os.path.join(directory, new_filename)
        
        # Don't do anything if the filename hasn't changed
        if new_file_path == file_path:
            return False
            
        # Check if the new file path already exists
        if os.path.exists(new_file_path) and new_file_path != file_path:
            QMessageBox.warning(
                self, 
                "File Already Exists", 
                f"Cannot rename to '{new_filename}': A file with this name already exists in the directory."
            )
            
            # Reset the table cell to the original filename
            for i, idx in enumerate(self.filtered_rows):
                if idx == file_index:
                    self.metadata_table.blockSignals(True)
                    self.metadata_table.item(i, 0).setText(old_filename)
                    self.metadata_table.blockSignals(False)
                    break
            return False
            
        # Create and push the rename command to the stack
        command = FileRenameCommand(self, file_index, file_path, new_file_path)
        if self.undo_redo_stack.push(command):
            self.status_label.setText(f"Renamed '{old_filename}' to '{new_filename}'")
            return True
        else:
            # Reset the table cell to the original filename if command failed
            for i, idx in enumerate(self.filtered_rows):
                if idx == file_index:
                    self.metadata_table.blockSignals(True)
                    self.metadata_table.item(i, 0).setText(old_filename)
                    self.metadata_table.blockSignals(False)
                    break
            return False
    
    def save_all_changes(self):
        # Get selected rows, if none are selected, show message
        selected_rows = self.get_selected_actual_rows()
        if not selected_rows:
            QMessageBox.information(self, "No Selection", "Please select the rows you want to save changes for.")
            return
            
        if not self.changes_pending:
            QMessageBox.information(self, "No Changes", "There are no pending changes to save.")
            return
        
        # Set up progress dialog
        progress = QProgressDialog("Saving changes...", "Cancel", 0, len(selected_rows), self)
        progress.setWindowModality(Qt.WindowModality.WindowModal)
        progress.setMinimumDuration(500)  # Only show if operation takes longer than 500ms
            
        success_count = 0
        error_count = 0
        
        # Process only selected rows
        for i, idx in enumerate(selected_rows):
            if progress.wasCanceled():
                break
                
            progress.setValue(i)
            progress.setLabelText(f"Saving {i+1}/{len(selected_rows)}: {os.path.basename(self.all_files[idx][0])}")
            QApplication.processEvents()
            
            file_path, metadata = self.all_files[idx]
            try:
                wav_metadata.write_wav_metadata(file_path, metadata)
                success_count += 1
            except Exception as e:
                error_count += 1
                print(f"Error updating metadata for {file_path}: {e}")
        
        # Close progress dialog
        progress.setValue(len(selected_rows))
                
        # Update status
        if error_count == 0:
            self.status_label.setText(f"Successfully updated metadata for {success_count} files")
            QMessageBox.information(self, "Success", f"Successfully updated metadata for {success_count} files")
        else:
            self.status_label.setText(f"Updated {success_count} files with {error_count} errors")
            QMessageBox.warning(self, "Partial Success", 
                               f"Updated {success_count} files with {error_count} errors. Check console for details.")
            
        self.changes_pending = False
    
    def get_selected_actual_rows(self):
        """Get the actual indices in all_files for selected table rows"""
        selected_ranges = self.metadata_table.selectedRanges()
        if not selected_ranges:
            return []
            
        selected_table_rows = set()
        for selection_range in selected_ranges:
            for row in range(selection_range.topRow(), selection_range.bottomRow() + 1):
                selected_table_rows.add(row)
                
        # Map visible table rows to actual file indices
        selected_actual_rows = [self.filtered_rows[row] for row in selected_table_rows 
                               if row < len(self.filtered_rows)]
        
        return selected_actual_rows
    
    def show_extraction_dialog(self):
        """Show dialog to extract metadata from filenames"""
        if not self.all_files:
            QMessageBox.warning(self, "No Files Loaded", "Please load WAV files first.")
            return
            
        # Get selected rows, if none are selected, show message
        selected_rows = self.get_selected_actual_rows()
        if not selected_rows:
            QMessageBox.information(self, "No Selection", 
                                   "Please select the rows you want to extract metadata for.")
            return
        
        dialog = FilenameExtractorDialog(self)
        # Pre-configure with the pattern PR2_Allen_Sc5.14D_01
        dialog.preset_common_pattern()
        
        if dialog.exec() == QDialog.DialogCode.Accepted:
            # Apply extraction only to selected files
            count = self.apply_filename_extraction(
                dialog.separator, 
                dialog.mappings,
                selected_rows
            )
            self.status_label.setText(f"Extracted metadata from {count} filenames")
            # Mark changes as pending
            self.changes_pending = True
    
    def apply_filename_extraction(self, separator, mappings, selected_rows=None):
        """Apply filename extraction to selected files based on dialog settings"""
        count = 0
        
        # If no rows specified, don't process any
        if selected_rows is None or not selected_rows:
            return 0
            
        # Disconnect signals temporarily
        self.metadata_table.blockSignals(True)
        
        # Set up batch processing with progress dialog
        progress = QProgressDialog("Extracting metadata...", "Cancel", 0, len(selected_rows), self)
        progress.setWindowModality(Qt.WindowModality.WindowModal)
        progress.setMinimumDuration(500)  # Only show if operation takes longer than 500ms
            
        for i, idx in enumerate(selected_rows):
            if progress.wasCanceled():
                break
                
            progress.setValue(i)
            progress.setLabelText(f"Processing {i+1}/{len(selected_rows)}: {os.path.basename(self.all_files[idx][0])}")
            QApplication.processEvents()
            
            if idx >= len(self.all_files):
                continue
                
            file_path, metadata = self.all_files[idx]
            filename = os.path.basename(file_path)
            # Remove the extension
            filename = os.path.splitext(filename)[0]
            
            # Split the filename using the separator
            parts = filename.split(separator)
            
            # Check if we have enough parts
            max_pos = max(int(pos) for field, pos in mappings)
            if len(parts) < max_pos:
                print(f"  Not enough parts: have {len(parts)}, need {max_pos}")
                continue
                
            # Extract metadata based on mappings
            updated = False
            for field, pos in mappings:
                try:
                    # Position is 1-based in UI, convert to 0-based for Python
                    idx = int(pos) - 1
                    
                    if idx >= len(parts):
                        print(f"  Index {idx} out of range for parts {parts}")
                        continue
                        
                    value = parts[idx]
                    print(f"  Mapping {field} from part {idx+1}: '{value}'")
                    
                    if field == "Scene" and idx < len(parts):
                        # Extract scene information
                        scene_part = value
                        # If scene follows format like "Sc5.14D", extract just the "5.14D" part
                        if scene_part.lower().startswith("sc"):
                            scene_part = scene_part[2:]
                            print(f"  Extracted Scene: '{scene_part}' from '{value}'")
                        
                        # Extract letter suffix if present and add to Slate
                        letter_match = re.search(r'[A-Za-z]+$', scene_part)
                        if letter_match:
                            letter_suffix = letter_match.group(0)
                            print(f"  Extracted letter suffix '{letter_suffix}' from Scene '{scene_part}'")
                            # Add to Slate field (preserve existing value if any)
                            existing_slate = metadata.get("Slate", "")
                            if existing_slate:
                                metadata["Slate"] = existing_slate + letter_suffix
                            else:
                                metadata["Slate"] = letter_suffix
                            print(f"  Added letter suffix to Slate: '{metadata['Slate']}'")
                            
                            # Optionally, you could remove the letter from the scene value
                            # scene_part = re.sub(r'[A-Za-z]+$', '', scene_part)
                            
                        metadata[field] = scene_part
                        updated = True
                    
                    elif field == "Subcategory" and idx < len(parts):
                        # Try to extract episode number from the filename
                        
                        # First check the scene part for a period (like in "5.14D")
                        scene_val = metadata.get("Scene", "")
                        if "." in scene_val:
                            # Extract episode number (before the period)
                            match = re.match(r'(\d+)\.', scene_val)
                            if match:
                                episode = match.group(1)
                                print(f"  Extracted episode '{episode}' from Scene '{scene_val}'")
                                metadata[field] = episode
                                updated = True
                                continue
                        
                        # If that didn't work, just use the direct mapping
                        metadata[field] = value
                        print(f"  Set {field} to '{value}'")
                        updated = True
                    
                    else:
                        # For other fields, just map directly
                        metadata[field] = value
                        print(f"  Set {field} to '{value}'")
                        updated = True
                        
                except (ValueError, IndexError) as e:
                    print(f"  Error processing {field} at position {pos}: {e}")
            
            if updated:
                count += 1
                self.all_files[i] = (file_path, metadata)
                print(f"  Updated metadata for {filename}")
                
        # After extraction complete, refresh the table
        self.update_table()
                
        return count

    def create_folder_icon(self):
        """Create a folder download icon from SVG"""
        # SVG icon for folder download
        svg_content = """
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <path d="M3 4C3 2.89543 3.89543 2 5 2H9L11 4H19C20.1046 4 21 4.89543 21 6V20C21 21.1046 20.1046 22 19 22H5C3.89543 22 3 21.1046 3 20V4Z" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
          <path d="M12 16L16 12M12 16L8 12M12 16V8" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        """
        
        # Create a QPixmap with transparent background
        icon_size = 24
        pixmap = QPixmap(icon_size, icon_size)
        pixmap.fill(Qt.GlobalColor.transparent)
        
        # Create a painter for the pixmap
        painter = QPainter(pixmap)
        
        # Load the SVG content
        svg_renderer = QSvgRenderer(bytearray(svg_content, encoding='utf-8'))
        
        # Render the SVG onto the pixmap
        svg_renderer.render(painter)
        
        # Finish painting
        painter.end()
        
        return QIcon(pixmap)
    
    def toggle_mirror_panel(self):
        """Toggle the visibility of the mirror panel"""
        # Get current visibility state
        is_visible = self.mirror_panel.isVisible()
        
        # Get selected rows if any
        selected_rows = self.get_selected_actual_rows()
        if selected_rows:
            # Update the selected rows in the mirror panel
            self.mirror_panel.set_selected_rows(selected_rows)
        self.mirror_panel.update_selected_count()
        
        # Toggle the panel visibility
        if not is_visible:
            # Show panel
            self.mirror_panel.setVisible(True)
            self.main_splitter.setSizes([self.width() - 400, 400])
        else:
            # Hide panel
            self.main_splitter.setSizes([self.width(), 0])
            self.mirror_panel.setVisible(False)
    
    # Property for animation (keeping for future use)
    def get_panel_position(self):
        return self.main_splitter.sizes()[1] if len(self.main_splitter.sizes()) > 1 else 0
        
    def set_panel_position(self, value):
        # This method will be called by the animation
        pass
        
    panel_position = pyqtProperty(int, get_panel_position, set_panel_position)

    def set_search_field(self, field):
        """Set the current search field and update the filter"""
        self.current_search_field = field
        self.filter_table()
    
    def show_field_menu(self):
        """Show a menu to select which field to search in"""
        menu = QMenu(self)
        for field in ["All Fields", "Filename", "Scene", "Take", "Category", "Subcategory", "Slate", "ixmlNote", "ixmlWildtrack", "ixmlCircled"]:
            action = QAction(field, self)
            action.triggered.connect(lambda checked, f=field: self.set_search_field(f))
            if field == self.current_search_field:
                action.setCheckable(True)
                action.setChecked(True)
            menu.addAction(action)
            
        # Position the menu below the button
        pos = self.search_field_button.mapToGlobal(self.search_field_button.rect().bottomLeft())
        menu.popup(pos)

    def create_sidebar_icon(self):
        """Create a custom sidebar toggle icon from SVG"""
        # SVG icon for sidebar toggle
        svg_content = """
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
          <rect x="4" y="4" width="16" height="16" rx="3" stroke="black" stroke-width="2"/>
          <rect x="14" y="6" width="4" height="12" rx="1" fill="black"/>
          <line x1="7" y1="8" x2="12" y2="8" stroke="black" stroke-width="2" stroke-linecap="round"/>
          <line x1="7" y1="12" x2="12" y2="12" stroke="black" stroke-width="2" stroke-linecap="round"/>
          <line x1="7" y1="16" x2="12" y2="16" stroke="black" stroke-width="2" stroke-linecap="round"/>
        </svg>
        """
        
        # Create a QPixmap with transparent background
        icon_size = 32  # Increased from 24 to 32
        pixmap = QPixmap(icon_size, icon_size)
        pixmap.fill(Qt.GlobalColor.transparent)
        
        # Create a painter for the pixmap
        painter = QPainter(pixmap)
        
        # Load the SVG content
        svg_renderer = QSvgRenderer(bytearray(svg_content, encoding='utf-8'))
        
        # Render the SVG onto the pixmap
        svg_renderer.render(painter)
        
        # Finish painting
        painter.end()
        
        return QIcon(pixmap)

    def toggleMaximized(self):
        """Toggle between maximized and normal window state"""
        if self.isMaximized():
            self.showNormal()
        else:
            self.showMaximized()

    def mousePressEvent(self, event):
        """Handle mouse press events for window dragging"""
        if event.button() == Qt.MouseButton.LeftButton:
            # Check if the click is in the top 40 pixels (title bar area)
            if event.position().y() <= 40:
                self._drag_pos = event.globalPosition().toPoint() - self.frameGeometry().topLeft()
                event.accept()
                self._is_dragging = True
                return
        
        # Let normal event processing continue
        self._is_dragging = False
        super().mousePressEvent(event)

    def mouseMoveEvent(self, event):
        """Handle mouse move events for window dragging"""
        if hasattr(self, '_drag_pos') and self._is_dragging and event.buttons() & Qt.MouseButton.LeftButton:
            self.move(event.globalPosition().toPoint() - self._drag_pos)
            event.accept()
        else:
            super().mouseMoveEvent(event)

    def mouseReleaseEvent(self, event):
        """Handle mouse release events for window dragging"""
        self._is_dragging = False
        super().mouseReleaseEvent(event)

    def create_integrated_title_bar(self, main_layout):
        """Create an integrated title bar with all controls"""
        # Create title bar container
        title_bar = QWidget()
        title_bar.setObjectName("title_bar")
        title_bar.setFixedHeight(44)  # Fixed height for the combined bar
        title_bar.setStyleSheet("""
            #title_bar {
                background-color: rgba(245, 236, 220, 0.85);
                border-top-left-radius: 10px;
                border-top-right-radius: 10px;
                border-bottom: 1px solid rgba(224, 216, 201, 0.7);
            }
        """)
        
        # Use horizontal layout for title bar
        title_layout = QHBoxLayout(title_bar)
        title_layout.setContentsMargins(10, 0, 10, 0)
        title_layout.setSpacing(8)
        
        # Window control buttons in macOS style (left side)
        close_button = QPushButton()
        close_button.setObjectName("close_button")
        close_button.setToolTip("Close")
        close_button.setFixedSize(12, 12)
        close_button.clicked.connect(self.close)
        
        minimize_button = QPushButton()
        minimize_button.setObjectName("minimize_button")
        minimize_button.setToolTip("Minimize")
        minimize_button.setFixedSize(12, 12)
        minimize_button.clicked.connect(self.showMinimized)
        
        self.maximize_button = QPushButton()
        self.maximize_button.setObjectName("maximize_button")
        self.maximize_button.setToolTip("Maximize")
        self.maximize_button.setFixedSize(12, 12)
        self.maximize_button.clicked.connect(self.toggleMaximized)
        
        # Add CSS for macOS style buttons
        close_button.setStyleSheet("""
            #close_button {
                background-color: #ff5f57;
                border-radius: 6px;
                border: none;
            }
            #close_button:hover {
                background-color: #ff7b76;
            }
        """)
        
        minimize_button.setStyleSheet("""
            #minimize_button {
                background-color: #ffbd2e;
                border-radius: 6px;
                border: none;
            }
            #minimize_button:hover {
                background-color: #ffcc51;
            }
        """)
        
        self.maximize_button.setStyleSheet("""
            #maximize_button {
                background-color: #28c941;
                border-radius: 6px;
                border: none;
            }
            #maximize_button:hover {
                background-color: #54d465;
            }
        """)
        
        # Add buttons to layout in macOS order (close, minimize, maximize)
        title_layout.addWidget(close_button)
        title_layout.addSpacing(4)
        title_layout.addWidget(minimize_button)
        title_layout.addSpacing(4)
        title_layout.addWidget(self.maximize_button)
        title_layout.addSpacing(10)
        
        # App title
        app_title = QLabel("Audio Metadata Editor")
        app_title.setObjectName("app_title")
        app_title.setStyleSheet("font-weight: bold; font-size: 14px;")
        title_layout.addWidget(app_title)
        
        # Add a small separator
        separator1 = QFrame()
        separator1.setFrameShape(QFrame.Shape.VLine)
        separator1.setFrameShadow(QFrame.Shadow.Sunken)
        separator1.setStyleSheet("background-color: rgba(224, 216, 201, 0.7); margin: 8px 4px;")
        title_layout.addWidget(separator1)
        
        # Integrated search widget with dropdown
        search_container = QWidget()
        search_layout = QHBoxLayout(search_container)
        search_layout.setContentsMargins(0, 0, 0, 0)
        search_layout.setSpacing(0)
        
        # Integrated search field with dropdown
        search_frame = QFrame()
        search_frame.setObjectName("search_frame")
        search_frame.setStyleSheet("""
            #search_frame {
                background-color: rgba(255, 255, 255, 0.85);
                border: 1px solid rgba(224, 216, 201, 0.8);
                border-radius: 6px;
            }
        """)
        
        search_frame_layout = QHBoxLayout(search_frame)
        search_frame_layout.setContentsMargins(5, 0, 5, 0)
        search_frame_layout.setSpacing(0)
        
        # First add the search input
        self.search_input = QLineEdit()
        self.search_input.setPlaceholderText("Search files...")
        self.search_input.setClearButtonEnabled(True)
        self.search_input.setMinimumWidth(180)
        self.search_input.setStyleSheet("""
            QLineEdit {
                border: none;
                background: transparent;
                padding: 4px;
            }
        """)
        self.search_input.textChanged.connect(self.on_search_changed)
        self.search_input.returnPressed.connect(self.filter_table)
        
        # Create a container for the field indicator and dropdown button
        dropdown_container = QWidget()
        dropdown_container.setFixedWidth(60)
        dropdown_layout = QHBoxLayout(dropdown_container)
        dropdown_layout.setContentsMargins(0, 0, 0, 0)
        dropdown_layout.setSpacing(0)
        
        # Field indicator and dropdown button
        field_indicator = QLabel("All")
        field_indicator.setObjectName("field_indicator")
        field_indicator.setStyleSheet("""
            #field_indicator {
                color: #666;
                padding-right: 0px;
            }
        """)
        
        dropdown_button = QPushButton("â–¾")
        dropdown_button.setObjectName("dropdown_button")
        dropdown_button.setFixedWidth(20)
        dropdown_button.setStyleSheet("""
            #dropdown_button {
                border: none;
                background: transparent;
                color: #666;
                padding: 0 5px 0 0;
                text-align: center;
                font-size: 10px;
            }
            #dropdown_button:hover {
                color: #333;
            }
        """)
        dropdown_button.clicked.connect(self.show_field_menu)
        
        # Add components to the dropdown container
        dropdown_layout.addWidget(field_indicator)
        dropdown_layout.addWidget(dropdown_button)
        
        # Add both components to the search frame layout in the correct order
        search_frame_layout.addWidget(self.search_input)
        search_frame_layout.addWidget(dropdown_container)
        
        search_layout.addWidget(search_frame)
        
        # Store references for updating
        self.field_indicator = field_indicator
        self.search_field_button = dropdown_button
        self.current_search_field = "All Fields"
        
        title_layout.addWidget(search_container)
        
        # Add a flex spacer to push the rest to the right
        title_layout.addStretch(1)
        
        # Action buttons
        
        # Browse button
        self.browse_button = QPushButton()
        self.browse_button.setIcon(self.create_folder_icon())
        self.browse_button.setToolTip("Browse for audio files (Ctrl+O)")
        self.browse_button.setProperty("class", "icon-button")
        self.browse_button.setFixedSize(32, 32)
        self.browse_button.clicked.connect(self.browse_folder)
        title_layout.addWidget(self.browse_button)
        
        # Extract button
        self.extract_button = QPushButton("Extract")
        self.extract_button.setToolTip("Extract metadata from filenames (Ctrl+E)")
        self.extract_button.setProperty("class", "action-button")
        self.extract_button.setFixedSize(70, 32)
        self.extract_button.clicked.connect(self.show_extraction_dialog)
        title_layout.addWidget(self.extract_button)
        
        # CSV match button
        self.csv_match_button = QPushButton("CSV Match")
        self.csv_match_button.setToolTip("Match metadata from CSV file (Ctrl+M)")
        self.csv_match_button.setProperty("class", "action-button")
        self.csv_match_button.setFixedSize(90, 32)
        self.csv_match_button.clicked.connect(self.show_csv_match_dialog)
        title_layout.addWidget(self.csv_match_button)
        
        # Save button
        self.save_button = QPushButton("Save")
        self.save_button.setToolTip("Save all changes (Ctrl+S)")
        self.save_button.setProperty("class", "action-button primary")
        self.save_button.setFixedSize(70, 32)
        self.save_button.clicked.connect(self.save_all_changes)
        title_layout.addWidget(self.save_button)
        
        # Add a separator
        separator2 = QFrame()
        separator2.setFrameShape(QFrame.Shape.VLine)
        separator2.setFrameShadow(QFrame.Shadow.Sunken)
        separator2.setStyleSheet("background-color: rgba(224, 216, 201, 0.7); margin: 8px 4px;")
        title_layout.addWidget(separator2)
        
        # Add undo button
        self.undo_button = QPushButton()
        self.undo_button.setIcon(self.create_undo_icon())
        self.undo_button.setToolTip("Undo (Ctrl+Z)")
        self.undo_button.setProperty("class", "icon-button")
        self.undo_button.setFixedSize(32, 32)
        self.undo_button.clicked.connect(self.undo)
        self.undo_button.setEnabled(False)  # Initially disabled
        title_layout.addWidget(self.undo_button)
        
        # Add redo button
        self.redo_button = QPushButton()
        self.redo_button.setIcon(self.create_redo_icon())
        self.redo_button.setToolTip("Redo (Ctrl+Shift+Z)")
        self.redo_button.setProperty("class", "icon-button")
        self.redo_button.setFixedSize(32, 32)
        self.redo_button.clicked.connect(self.redo)
        self.redo_button.setEnabled(False)  # Initially disabled
        title_layout.addWidget(self.redo_button)
        
        # Sidebar toggle button
        self.sidebar_toggle = QPushButton()
        self.sidebar_toggle.setIcon(self.create_sidebar_icon())
        self.sidebar_toggle.setToolTip("Toggle Mirror Panel (Ctrl+T)")
        self.sidebar_toggle.setProperty("class", "icon-button")
        self.sidebar_toggle.setFixedSize(32, 32)
        self.sidebar_toggle.clicked.connect(self.toggle_mirror_panel)
        title_layout.addWidget(self.sidebar_toggle)
        
        # Add title bar to main layout
        main_layout.addWidget(title_bar)
    
    def show_csv_match_dialog(self):
        """Show dialog to match metadata from CSV file"""
        if not self.all_files:
            QMessageBox.warning(self, "No Files Loaded", "Please load WAV files first.")
            return
            
        wizard = CSVMatchWizard(self)
        if wizard.exec() == QDialog.DialogCode.Accepted:
            # Get matched characters
            character_matches = wizard.character_matches
            
            # Get field mappings
            field_mappings = wizard.get_field_mappings()
            
            # Get matching columns
            character_column = wizard.character_column
            scene_column = wizard.scene_column
            take_column = wizard.take_column
            
            # Match and update metadata
            updated_count = self.apply_csv_matches(
                wizard.csv_data,
                wizard.csv_headers,
                character_matches,
                character_column,
                scene_column,
                take_column,
                field_mappings
            )
            
            # Update table with matched metadata
            self.update_table()
            self.status_label.setText(f"Updated {updated_count} files with CSV metadata")
            
            # Mark changes as pending
            self.changes_pending = True

    def apply_csv_matches(self, csv_data, csv_headers, character_matches, character_column, scene_column, take_column, field_mappings):
        """Apply CSV matches to audio files
        
        Args:
            csv_data: List of csv rows
            csv_headers: List of csv column headers
            character_matches: Dict mapping audio characters to csv characters
            character_column: CSV column name for character matching
            scene_column: CSV column name for scene matching
            take_column: CSV column name for take matching
            field_mappings: Dict mapping CSV field names to audio metadata fields
        """
        # Get column indices
        char_col_idx = csv_headers.index(character_column)
        scene_col_idx = csv_headers.index(scene_column)
        take_col_idx = csv_headers.index(take_column)
        
        # Create a lookup dictionary for CSV rows by character, scene, and take
        csv_lookup = {}
        for row in csv_data:
            if len(row) <= max(char_col_idx, scene_col_idx, take_col_idx):
                continue
                
            char = row[char_col_idx]
            scene = row[scene_col_idx]
            take = row[take_col_idx]
            
            # Create a lookup key
            key = (char, scene, take)
            csv_lookup[key] = row
        
        # Count of updated files
        updated_count = 0
        
        # Match and update audio file metadata
        for i, (file_path, metadata) in enumerate(self.all_files):
            # Get audio file character, scene, and take
            audio_char = metadata.get("Category", "")
            audio_scene = metadata.get("Scene", "")
            audio_take = metadata.get("Take", "")
            
            # Skip if missing any required field
            if not audio_char or not audio_scene or not audio_take:
                continue
                
            # Skip if character not matched
            if audio_char not in character_matches:
                continue
                
            # Get matched CSV character
            csv_char = character_matches[audio_char]
            
            # Try to find matching CSV row
            key = (csv_char, audio_scene, audio_take)
            if key in csv_lookup:
                # Get the matching CSV row
                csv_row = csv_lookup[key]
                
                # Update metadata with mapped fields
                updated = False
                for csv_field, target_field in field_mappings.items():
                    if csv_field in csv_headers:
                        field_idx = csv_headers.index(csv_field)
                        if field_idx < len(csv_row) and csv_row[field_idx]:
                            # Map CSV field to the specified audio metadata field
                            metadata[target_field] = csv_row[field_idx]
                            updated = True
                
                if updated:
                    # Update the all_files list with the new metadata
                    self.all_files[i] = (file_path, metadata)
                    updated_count += 1
        
        return updated_count

    def undo(self):
        """Undo the last operation"""
        if self.undo_redo_stack.undo():
            self.status_label.setText(f"Undo successful")
            self.update_undo_redo_buttons()
    
    def redo(self):
        """Redo the last undone operation"""
        if self.undo_redo_stack.redo():
            self.status_label.setText(f"Redo successful")
            self.update_undo_redo_buttons()
    
    def update_undo_redo_buttons(self):
        """Update the state of undo/redo buttons based on stack state"""
        # Enable or disable the undo button
        can_undo = self.undo_redo_stack.can_undo()
        self.undo_button.setEnabled(can_undo)
        
        # Set a more descriptive tooltip if an undo command is available
        if can_undo:
            command = self.undo_redo_stack.command_to_undo()
            if command:
                self.undo_button.setToolTip(f"Undo {command.description} (Ctrl+Z)")
            else:
                self.undo_button.setToolTip("Undo (Ctrl+Z)")
        else:
            self.undo_button.setToolTip("Undo (Ctrl+Z) - Nothing to undo")
        
        # Enable or disable the redo button
        can_redo = self.undo_redo_stack.can_redo()
        self.redo_button.setEnabled(can_redo)
        
        # Set a more descriptive tooltip if a redo command is available
        if can_redo:
            command = self.undo_redo_stack.command_to_redo()
            if command:
                self.redo_button.setToolTip(f"Redo {command.description} (Ctrl+Shift+Z)")
            else:
                self.redo_button.setToolTip("Redo (Ctrl+Shift+Z)")
        else:
            self.redo_button.setToolTip("Redo (Ctrl+Shift+Z) - Nothing to redo")
    
    def create_undo_icon(self):
        """Create an undo icon"""
        # SVG icon for undo
        svg_content = """
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M3 10H13C15.7614 10 18 12.2386 18 15V15C18 17.7614 15.7614 20 13 20H10" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M7 6L3 10L7 14" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        """
        
        # Create a QPixmap with transparent background
        icon_size = 24
        pixmap = QPixmap(icon_size, icon_size)
        pixmap.fill(Qt.GlobalColor.transparent)
        
        # Create a painter for the pixmap
        painter = QPainter(pixmap)
        
        # Load the SVG content
        svg_renderer = QSvgRenderer(bytearray(svg_content, encoding='utf-8'))
        
        # Render the SVG onto the pixmap
        svg_renderer.render(painter)
        
        # Finish painting
        painter.end()
        
        # Return QIcon instead of QPixmap
        return QIcon(pixmap)
    
    def create_redo_icon(self):
        """Create a redo icon"""
        # SVG icon for redo
        svg_content = """
        <svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg">
            <path d="M21 10H11C8.23858 10 6 12.2386 6 15V15C6 17.7614 8.23858 20 11 20H14" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
            <path d="M17 6L21 10L17 14" stroke="black" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"/>
        </svg>
        """
        
        # Create a QPixmap with transparent background
        icon_size = 24
        pixmap = QPixmap(icon_size, icon_size)
        pixmap.fill(Qt.GlobalColor.transparent)
        
        # Create a painter for the pixmap
        painter = QPainter(pixmap)
        
        # Load the SVG content
        svg_renderer = QSvgRenderer(bytearray(svg_content, encoding='utf-8'))
        
        # Render the SVG onto the pixmap
        svg_renderer.render(painter)
        
        # Finish painting
        painter.end()
        
        # Return QIcon instead of QPixmap
        return QIcon(pixmap)

    def setup_shortcuts(self):
        """Set up keyboard shortcuts for the application"""
        from PyQt6.QtGui import QKeySequence, QShortcut
        
        # Browse shortcut (Ctrl+O)
        browse_shortcut = QShortcut(QKeySequence("Ctrl+O"), self)
        browse_shortcut.activated.connect(self.browse_folder)
        
        # Save shortcut (Ctrl+S)
        save_shortcut = QShortcut(QKeySequence("Ctrl+S"), self)
        save_shortcut.activated.connect(self.save_all_changes)
        
        # Extract shortcut (Ctrl+E)
        extract_shortcut = QShortcut(QKeySequence("Ctrl+E"), self)
        extract_shortcut.activated.connect(self.show_extraction_dialog)
        
        # CSV Match shortcut (Ctrl+M)
        csv_match_shortcut = QShortcut(QKeySequence("Ctrl+M"), self)
        csv_match_shortcut.activated.connect(self.show_csv_match_dialog)
        
        # Toggle panel shortcut (Ctrl+T)
        toggle_panel_shortcut = QShortcut(QKeySequence("Ctrl+T"), self)
        toggle_panel_shortcut.activated.connect(self.toggle_mirror_panel)
        
        # Undo shortcut (Ctrl+Z)
        undo_shortcut = QShortcut(QKeySequence("Ctrl+Z"), self)
        undo_shortcut.activated.connect(self.undo)
        
        # Redo shortcut (Ctrl+Shift+Z or Ctrl+Y)
        redo_shortcut_1 = QShortcut(QKeySequence("Ctrl+Shift+Z"), self)
        redo_shortcut_1.activated.connect(self.redo)
        
        redo_shortcut_2 = QShortcut(QKeySequence("Ctrl+Y"), self)
        redo_shortcut_2.activated.connect(self.redo)

    def select_search_field(self, field):
        """Set the field to search in"""
        self.current_search_field = field
        
        # Update the field indicator label
        display_text = field if field != "All Fields" else "All"
        self.field_indicator.setText(display_text)
        
        # Apply current filter
        self.filter_table()


class FilenameExtractorDialog(QDialog):
    """Dialog for configuring filename metadata extraction"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Extract Metadata from Filename")
        # Remove fixed size to allow resize and make dialog smaller
        self.resize(480, 380)
        
        # Store the mappings of fields to positions
        self.mappings = []
        self.separator = "_"  # Default separator
        
        # Create a more compact, efficient layout
        layout = QVBoxLayout(self)
        layout.setContentsMargins(16, 16, 16, 16)
        layout.setSpacing(12)
        
        # Header with explanation - simplified
        header_layout = QHBoxLayout()
        header = QLabel("Extract Metadata")
        header.setStyleSheet("font-size: 16px; font-weight: 500;")
        header_layout.addWidget(header)
        header_layout.addStretch()
        layout.addLayout(header_layout)
        
        # Example pattern - more compact
        self.example_label = QLabel("Example: PR2_Allen_Sc5.14D_01 â†’ Show/Category/Scene/Take")
        self.example_label.setStyleSheet("font-style: italic; color: #666; font-size: 12px;")
        layout.addWidget(self.example_label)
        
        # Separator selection - more compact
        separator_layout = QHBoxLayout()
        separator_layout.setSpacing(8)
        
        separator_label = QLabel("Separator:")
        separator_label.setFixedWidth(70)
        separator_layout.addWidget(separator_label)
        
        # Separator input
        self.separator_input = QLineEdit("_")
        self.separator_input.setFixedWidth(40)
        separator_layout.addWidget(self.separator_input)
        
        # Preset button
        preset_button = QPushButton("Use Common Pattern")
        preset_button.setProperty("class", "mac-button")
        preset_button.clicked.connect(self.preset_common_pattern)
        separator_layout.addWidget(preset_button)
        
        separator_layout.addStretch()
        layout.addLayout(separator_layout)
        
        # Mapping rules section heading
        mapping_label = QLabel("Mapping Rules:")
        mapping_label.setStyleSheet("font-weight: 500; margin-top: 8px;")
        layout.addWidget(mapping_label)
        
        # Mapping grid - more efficient layout
        mapping_container = QWidget()
        mapping_grid = QGridLayout(mapping_container)
        mapping_grid.setContentsMargins(0, 0, 0, 0)
        mapping_grid.setSpacing(8)
        mapping_grid.setHorizontalSpacing(10)
        
        # Column headers
        mapping_grid.addWidget(QLabel("Item"), 0, 0)
        mapping_grid.addWidget(QLabel("Position"), 0, 1)
        mapping_grid.addWidget(QLabel("Field"), 0, 2)
        
        # Add mapping rows (up to 5 initially)
        self.mapping_layouts = []
        for i in range(5):
            # Position spinbox
            position = QSpinBox()
            position.setMinimum(1)
            position.setMaximum(10)
            position.setValue(i+1)
            position.setFixedWidth(50)
            
            # Target field dropdown
            target_field = QComboBox()
            target_field.addItems(["Show", "Category", "Subcategory", "Scene", "Take"])
            target_field.setFixedWidth(130)
            
            # Default mapping (will be overridden by preset_common_pattern)
            if i == 0:
                target_field.setCurrentText("Show")
            elif i == 1:
                target_field.setCurrentText("Category")
            elif i == 2:
                target_field.setCurrentText("Scene")
            elif i == 3:
                target_field.setCurrentText("Take")
            elif i == 4:
                target_field.setCurrentText("Subcategory")
            
            # Add to grid layout
            mapping_grid.addWidget(QLabel(f"#{i+1}"), i+1, 0)
            mapping_grid.addWidget(position, i+1, 1)
            mapping_grid.addWidget(target_field, i+1, 2)
            
            self.mapping_layouts.append((position, target_field))
        
        layout.addWidget(mapping_container)
        layout.addStretch()
        
        # Buttons in a nicer layout
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        cancel_button = QPushButton("Cancel")
        cancel_button.setFixedWidth(80)
        cancel_button.setProperty("class", "mac-button")
        cancel_button.clicked.connect(self.reject)
        button_layout.addWidget(cancel_button)
        
        apply_button = QPushButton("Apply")
        apply_button.setFixedWidth(80)
        apply_button.setProperty("class", "mac-button primary")
        apply_button.setStyleSheet(".mac-button.primary { background-color: #007AFF; color: white; }")
        apply_button.clicked.connect(self.accept)
        button_layout.addWidget(apply_button)
        
        layout.addLayout(button_layout)
    
    def preset_common_pattern(self):
        """Set a preset for the common pattern PR2_Allen_Sc5.14D_01"""
        # Update the example label for clarity
        self.example_label.setText("Example: PR2_Allen_Sc5.14D_01 â†’ Show, Character, Scene (with Sc prefix), Take")
        
        # Set separator
        self.separator_input.setText("_")
        
        # Configure mappings for the standard pattern
        # 1. Show (PR2)
        # 2. Category/Character (Allen)
        # 3. Scene with "Sc" prefix (Sc5.14D) - code will strip the "Sc"
        # 4. Take (01)
        # (Subcategory will be extracted from scene number)
        
        # Set up the mapping controls
        for i, (position, field) in enumerate(self.mapping_layouts):
            if i == 0:
                position.setValue(1)
                field.setCurrentText("Show")
            elif i == 1:
                position.setValue(2)
                field.setCurrentText("Category")
            elif i == 2:
                position.setValue(3)
                field.setCurrentText("Scene")
            elif i == 3:
                position.setValue(4)
                field.setCurrentText("Take")
            elif i == 4:
                # This will be auto-extracted from Scene
                position.setValue(1)  # Doesn't matter - will be extracted from Scene
                field.setCurrentText("Subcategory")

    def accept(self):
        """When user clicks Apply, gather all the settings"""
        self.separator = self.separator_input.text()
        if not self.separator:
            self.separator = "_"  # Default if empty
        
        # Gather the mappings
        self.mappings = []
        for position, target_field in self.mapping_layouts:
            field = target_field.currentText()
            pos = position.value()
            self.mappings.append((field, pos))
        
        super().accept()


class MirrorFilesDialog(QDialog):
    """Dialog for configuring file mirroring options"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.setWindowTitle("Mirror Files to New Location")
        self.resize(550, 400)
        
        # Initialize variables
        self.destination_dir = ""
        self.organization = []
        
        # Create layout
        layout = QVBoxLayout(self)
        layout.setContentsMargins(16, 16, 16, 16)
        layout.setSpacing(12)
        
        # Set dialog background to light color
        self.setStyleSheet("""
            QDialog {
                background-color: #F5F5F7;
            }
            QLabel {
                color: #333333;
            }
            QGroupBox {
                background-color: white;
                border: 1px solid #E0E0E0;
                border-radius: 4px;
                margin-top: 12px;
                font-weight: bold;
                color: #333333;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
                color: #333333;
            }
            QListWidget {
                background-color: white;
                border: 1px solid #E0E0E0;
                color: #333333;
            }
            QPushButton {
                background-color: #E9E9E9;
                color: #333333;
                border: 1px solid #D0D0D0;
                border-radius: 4px;
                padding: 5px 10px;
                min-height: 20px;
            }
            QPushButton:hover {
                background-color: #D0D0D0;
            }
            QPushButton.primary {
                background-color: #007AFF;
                color: white;
                border: none;
            }
            QPushButton.primary:hover {
                background-color: #0066CC;
            }
            QLineEdit, QSpinBox {
                padding: 5px;
                border: 1px solid #D0D0D0;
                border-radius: 4px;
                background-color: white;
                color: #333333;
            }
            QCheckBox {
                color: #333333;
            }
        """)
        
        # Header with explanation
        header = QLabel("Mirror Files")
        header.setStyleSheet("font-size: 18px; font-weight: 600; color: #333333; margin-bottom: 5px;")
        layout.addWidget(header)
        
        info_label = QLabel("Copy selected files to a new location with organized folder structure.")
        info_label.setStyleSheet("font-style: italic; color: #666666; font-size: 13px; margin-bottom: 10px;")
        layout.addWidget(info_label)
        
        # Destination directory selection
        dest_group = QGroupBox("Destination Folder")
        dest_layout = QHBoxLayout(dest_group)
        dest_layout.setContentsMargins(12, 12, 12, 12)
        
        self.dest_input = QLineEdit()
        self.dest_input.setPlaceholderText("Select destination folder...")
        dest_layout.addWidget(self.dest_input)
        
        dest_button = QPushButton("Browse...")
        dest_button.setFixedWidth(100)
        dest_button.clicked.connect(self.browse_destination)
        dest_layout.addWidget(dest_button)
        
        layout.addWidget(dest_group)
        
        # Folder organization section - main content area
        org_group = QGroupBox("Folder Organization")
        org_main_layout = QVBoxLayout(org_group)
        org_main_layout.setContentsMargins(12, 16, 12, 12)
        
        # Explanation for this section
        org_info = QLabel("Select fields to create an organized folder structure. Order determines hierarchy.")
        org_info.setStyleSheet("font-style: italic; color: #666666; font-size: 12px; margin-bottom: 8px;")
        org_main_layout.addWidget(org_info)
        
        # Split into two columns - available fields and selected fields
        org_layout = QHBoxLayout()
        
        # Available fields list
        available_group = QGroupBox("Available Fields")
        available_layout = QVBoxLayout(available_group)
        available_layout.setContentsMargins(10, 20, 10, 10)
        
        self.available_list = QListWidget()
        self.available_list.addItems(["Show", "Scene", "Take", "Category", "Subcategory", "Slate", "ixmlNote", "ixmlWildtrack", "ixmlCircled"])
        self.available_list.setSelectionMode(QListWidget.SelectionMode.ExtendedSelection)
        available_layout.addWidget(self.available_list)
        
        org_layout.addWidget(available_group)
        
        # Buttons for moving fields between lists
        button_layout = QVBoxLayout()
        button_layout.addStretch()
        
        add_button = QPushButton("â†’")
        add_button.setFixedSize(40, 30)
        add_button.clicked.connect(self.add_fields)
        button_layout.addWidget(add_button)
        
        remove_button = QPushButton("â†")
        remove_button.setFixedSize(40, 30)
        remove_button.clicked.connect(self.remove_fields)
        button_layout.addWidget(remove_button)
        
        button_layout.addSpacing(20)
        
        up_button = QPushButton("â†‘")
        up_button.setFixedSize(40, 30)
        up_button.clicked.connect(self.move_field_up)
        button_layout.addWidget(up_button)
        
        down_button = QPushButton("â†“")
        down_button.setFixedSize(40, 30)
        down_button.clicked.connect(self.move_field_down)
        button_layout.addWidget(down_button)
        
        button_layout.addStretch()
        org_layout.addLayout(button_layout)
        
        # Selected fields list
        selected_group = QGroupBox("Selected Order (Top to Bottom)")
        selected_layout = QVBoxLayout(selected_group)
        selected_layout.setContentsMargins(10, 20, 10, 10)
        
        self.selected_list = QListWidget()
        self.selected_list.setSelectionMode(QListWidget.SelectionMode.ExtendedSelection)
        selected_layout.addWidget(self.selected_list)
        
        org_layout.addWidget(selected_group)
        
        org_main_layout.addLayout(org_layout)
        
        # Preview section
        preview_group = QGroupBox("Preview")
        preview_layout = QVBoxLayout(preview_group)
        preview_layout.setContentsMargins(10, 20, 10, 10)
        
        self.example_text = QLabel("Select fields to see example folder structure")
        self.example_text.setStyleSheet("font-family: monospace; color: #333333; background-color: #EAEAEA; padding: 8px; border-radius: 4px;")
        self.example_text.setWordWrap(True)
        preview_layout.addWidget(self.example_text)
        
        org_main_layout.addWidget(preview_group)
        
        # Options
        options_layout = QHBoxLayout()
        
        self.overwrite_checkbox = QCheckBox("Overwrite existing files")
        self.overwrite_checkbox.setStyleSheet("color: #333333;")
        options_layout.addWidget(self.overwrite_checkbox)
        
        org_main_layout.addLayout(options_layout)
        
        layout.addWidget(org_group)
        
        # Connect signals for preview updates
        self.selected_list.model().rowsInserted.connect(self.update_preview)
        self.selected_list.model().rowsRemoved.connect(self.update_preview)
        self.selected_list.model().layoutChanged.connect(self.update_preview)
        
        # Buttons
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        cancel_button = QPushButton("Cancel")
        cancel_button.setFixedWidth(90)
        cancel_button.clicked.connect(self.reject)
        button_layout.addWidget(cancel_button)
        
        mirror_button = QPushButton("Mirror")
        mirror_button.setFixedWidth(90)
        mirror_button.setProperty("class", "primary")
        mirror_button.clicked.connect(self.accept)
        button_layout.addWidget(mirror_button)
        
        layout.addLayout(button_layout)
    
    def browse_destination(self):
        """Browse for destination directory"""
        folder_path = QFileDialog.getExistingDirectory(self, "Select Destination Folder")
        if folder_path:
            self.dest_input.setText(folder_path)
            self.destination_dir = folder_path
    
    def add_fields(self):
        """Add selected fields from available to selected"""
        for item in self.available_list.selectedItems():
            # Create a new item to add to selected list
            new_item = item.text()
            self.selected_list.addItem(new_item)
            
            # Remove from available list
            self.available_list.takeItem(self.available_list.row(item))
    
    def remove_fields(self):
        """Remove selected fields from selected to available"""
        for item in self.selected_list.selectedItems():
            # Create a new item to add back to available list
            new_item = item.text()
            self.available_list.addItem(new_item)
            
            # Remove from selected list
            self.selected_list.takeItem(self.selected_list.row(item))
    
    def move_field_up(self):
        """Move selected field up in the list"""
        current_row = self.selected_list.currentRow()
        if current_row > 0:
            current_item = self.selected_list.takeItem(current_row)
            self.selected_list.insertItem(current_row - 1, current_item)
            self.selected_list.setCurrentRow(current_row - 1)
    
    def move_field_down(self):
        """Move selected field down in the list"""
        current_row = self.selected_list.currentRow()
        if current_row < self.selected_list.count() - 1:
            current_item = self.selected_list.takeItem(current_row)
            self.selected_list.insertItem(current_row + 1, current_item)
            self.selected_list.setCurrentRow(current_row + 1)
    
    def update_preview(self):
        """Update the preview of folder structure"""
        if self.selected_list.count() == 0:
            self.example_text.setText("Select fields to see example folder structure")
            return
            
        # Build example structure
        structure = "destination/"
        for i in range(self.selected_list.count()):
            field = self.selected_list.item(i).text()
            structure += f"<{field}>/"
            
        # Add example values for clearer visualization
        example = structure.replace("<Show>", "<Show: PR2>")
        example = example.replace("<Scene>", "<Scene: 2.14B>")
        example = example.replace("<Take>", "<Take: 03>")
        example = example.replace("<Category>", "<Category: Andre>")
        example = example.replace("<Subcategory>", "<Subcategory: 2>")
        
        self.example_text.setText(example)
    
    def accept(self):
        """When user clicks Mirror, gather all the settings"""
        self.destination_dir = self.dest_input.text()
        if not self.destination_dir:
            QMessageBox.warning(self, "No Destination", "Please select a destination folder.")
            return
            
        # Gather the selected fields in order
        self.organization = []
        for i in range(self.selected_list.count()):
            self.organization.append(self.selected_list.item(i).text())
            
        if not self.organization:
            QMessageBox.warning(self, "No Organization", "Please select at least one field for folder organization.")
            return
            
        overwrite = self.overwrite_checkbox.isChecked()
        
        # Call the parent's mirror method
        self.parent.mirror_files(self.selected_rows, self.destination_dir, self.organization, overwrite)


class MirrorPanel(QWidget):
    """Side panel for configuring and executing file mirroring options"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent = parent
        self.selected_rows = []
        self.destination_dir = ""
        self.organization = []
        
        # Set the object name for styling
        self.setObjectName("MirrorPanel")
        
        # Setup UI
        self.setup_ui()
    
    def setup_ui(self):
        # Create main layout
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(0, 0, 0, 0)
        main_layout.setSpacing(0)
        
        # Create scroll area for content
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setFrameShape(QFrame.Shape.NoFrame)
        scroll_area.setHorizontalScrollBarPolicy(Qt.ScrollBarPolicy.ScrollBarAlwaysOff)
        
        # Create content widget to hold all panel elements
        content_widget = QWidget()
        content_widget.setObjectName("MirrorPanelContent")
        content_layout = QVBoxLayout(content_widget)
        content_layout.setContentsMargins(16, 16, 16, 16)
        content_layout.setSpacing(12)
        
        # Set panel styling
        self.setStyleSheet("""
            QWidget#MirrorPanel {
                background-color: rgba(245, 236, 220, 0.75);
                border-left: 1px solid rgba(224, 216, 201, 0.7);
            }
            QWidget#MirrorPanelContent {
                background-color: rgba(245, 236, 220, 0.5);
            }
            QLabel {
                color: #333333;
            }
            QGroupBox {
                background-color: rgba(245, 236, 220, 0.6);
                border: 1px solid rgba(224, 216, 201, 0.7);
                border-radius: 4px;
                margin-top: 12px;
                font-weight: bold;
                color: #333333;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
                color: #333333;
            }
            QListWidget {
                background-color: rgba(255, 255, 255, 0.8);
                border: 1px solid rgba(224, 216, 201, 0.7);
                color: #333333;
                min-height: 80px;
            }
            QListWidget::item {
                color: #333333;
                padding: 4px;
            }
            QListWidget::item:selected {
                background-color: rgba(232, 223, 208, 0.7);
                color: #333333;
            }
            QPushButton {
                background-color: rgba(245, 236, 220, 0.6);
                color: #333333;
                border: 1px solid rgba(224, 216, 201, 0.7);
                border-radius: 4px;
                padding: 5px 10px;
                min-height: 20px;
            }
            QPushButton:hover {
                background-color: rgba(232, 223, 208, 0.8);
            }
            QPushButton.primary {
                background-color: rgba(196, 181, 159, 0.85);
                color: white;
                border: none;
            }
            QPushButton.primary:hover {
                background-color: rgba(181, 167, 144, 0.95);
            }
            QLineEdit, QSpinBox {
                padding: 5px;
                border: 1px solid rgba(224, 216, 201, 0.7);
                border-radius: 4px;
                background-color: rgba(255, 255, 255, 0.8);
                color: #333333;
            }
            QCheckBox {
                color: #333333;
            }
            QScrollArea {
                background-color: transparent;
                border: none;
            }
            QSplitter::handle {
                background-color: rgba(224, 216, 201, 0.5);
                height: 1px;
            }
            QFrame[frameShape="4"] {  /* HLine */
                background-color: rgba(224, 216, 201, 0.5);
                max-height: 1px;
            }
            
            /* QScrollBar styling */
            QScrollBar:vertical {
                border: none;
                background: rgba(245, 236, 220, 0.3);
                width: 8px;
                margin: 0px;
                border-radius: 4px;
            }
            
            QScrollBar::handle:vertical {
                background: rgba(196, 181, 159, 0.7);
                min-height: 20px;
                border-radius: 4px;
            }
            
            QScrollBar::add-line:vertical, QScrollBar::sub-line:vertical {
                border: none;
                background: none;
                height: 0px;
            }
            
            QScrollBar:horizontal {
                border: none;
                background: rgba(245, 236, 220, 0.3);
                height: 8px;
                margin: 0px;
                border-radius: 4px;
            }
            
            QScrollBar::handle:horizontal {
                background: rgba(196, 181, 159, 0.7);
                min-width: 20px;
                border-radius: 4px;
            }
            
            QScrollBar::add-line:horizontal, QScrollBar::sub-line:horizontal {
                border: none;
                background: none;
                width: 0px;
            }
        """)
        
        # Header section
        header_container = QWidget()
        header_layout = QVBoxLayout(header_container)
        header_layout.setContentsMargins(0, 0, 0, 0)
        header_layout.setSpacing(4)
        
        header = QLabel("Mirror Files")
        header.setStyleSheet("font-size: 18px; font-weight: 600; color: #333333; margin-bottom: 5px;")
        header_layout.addWidget(header)
        
        info_label = QLabel("Copy selected files to a new location with organized folder structure.")
        info_label.setStyleSheet("font-style: italic; color: #666666; font-size: 13px; margin-bottom: 10px;")
        info_label.setWordWrap(True)
        header_layout.addWidget(info_label)
        
        # File count label
        self.file_count_label = QLabel("No files selected. Select files in the main panel.")
        self.file_count_label.setStyleSheet("color: #FF3B30; font-weight: bold; font-style: italic;")
        header_layout.addWidget(self.file_count_label)
        
        content_layout.addWidget(header_container)
        
        # Destination directory selection - simplified
        dest_container = QWidget()
        dest_container.setStyleSheet("background-color: rgba(245, 236, 220, 0.5);")
        dest_layout = QVBoxLayout(dest_container)
        dest_layout.setContentsMargins(0, 0, 0, 0)
        dest_layout.setSpacing(8)
        
        dest_label = QLabel("Destination Folder:")
        dest_label.setStyleSheet("font-weight: bold; color: #333333;")
        dest_layout.addWidget(dest_label)
        
        dest_input_layout = QHBoxLayout()
        dest_input_layout.setContentsMargins(0, 0, 0, 0)
        dest_input_layout.setSpacing(8)
        
        self.dest_input = QLineEdit()
        self.dest_input.setPlaceholderText("Select destination folder...")
        dest_input_layout.addWidget(self.dest_input)
        
        dest_button = QPushButton("Browse...")
        dest_button.setMaximumWidth(80)
        dest_button.clicked.connect(self.browse_destination)
        dest_input_layout.addWidget(dest_button)
        
        dest_layout.addLayout(dest_input_layout)
        content_layout.addWidget(dest_container)
        
        # Add separator
        separator = QFrame()
        separator.setFrameShape(QFrame.Shape.HLine)
        separator.setFrameShadow(QFrame.Shadow.Sunken)
        content_layout.addWidget(separator)
        
        # QCODE Take Review section - simplified
        qcode_container = QWidget()
        qcode_container.setStyleSheet("background-color: rgba(245, 236, 220, 0.5);")
        qcode_layout = QVBoxLayout(qcode_container)
        qcode_layout.setContentsMargins(0, 0, 0, 0)
        qcode_layout.setSpacing(8)
        
        qcode_label = QLabel("QCODE Take Review")
        qcode_label.setStyleSheet("font-weight: bold; font-size: 14px; color: #333333;")
        qcode_layout.addWidget(qcode_label)
        
        qcode_info = QLabel("Mirror files in QCODE Take Review format with two copies:\n1. By Episode/Character/Episode/Scene\n2. Day X/Character")
        qcode_info.setStyleSheet("font-style: italic; color: #666666; font-size: 12px;")
        qcode_info.setWordWrap(True)
        qcode_layout.addWidget(qcode_info)
        
        # Day number input
        day_layout = QHBoxLayout()
        day_layout.setContentsMargins(0, 0, 0, 0)
        
        day_label = QLabel("Day Number:")
        day_label.setStyleSheet("color: #333333;")
        day_label.setFixedWidth(100)
        day_layout.addWidget(day_label)
        
        self.day_spinner = QSpinBox()
        self.day_spinner.setMinimum(1)
        self.day_spinner.setMaximum(99)
        self.day_spinner.setValue(1)
        day_layout.addWidget(self.day_spinner)
        day_layout.addStretch()
        
        qcode_layout.addLayout(day_layout)
        
        # QCODE mirror button
        qcode_mirror_button = QPushButton("Mirror for QCODE Take Review")
        qcode_mirror_button.setProperty("class", "primary")
        qcode_mirror_button.clicked.connect(self.mirror_for_qcode)
        qcode_layout.addWidget(qcode_mirror_button)
        
        content_layout.addWidget(qcode_container)
        
        # Add separator
        separator2 = QFrame()
        separator2.setFrameShape(QFrame.Shape.HLine)
        separator2.setFrameShadow(QFrame.Shadow.Sunken)
        content_layout.addWidget(separator2)
        
        # Custom folder organization section - with splitter
        custom_org_container = QWidget()
        custom_org_container.setStyleSheet("background-color: rgba(245, 236, 220, 0.5);")
        custom_org_layout = QVBoxLayout(custom_org_container)
        custom_org_layout.setContentsMargins(0, 0, 0, 0)
        custom_org_layout.setSpacing(8)
        
        custom_org_label = QLabel("Custom Folder Organization")
        custom_org_label.setStyleSheet("font-weight: bold; font-size: 14px; color: #333333;")
        custom_org_layout.addWidget(custom_org_label)
        
        org_info = QLabel("Select fields to create an organized folder structure. Order determines hierarchy.")
        org_info.setStyleSheet("font-style: italic; color: #666666; font-size: 12px;")
        org_info.setWordWrap(True)
        custom_org_layout.addWidget(org_info)
        
        # Create splitter for field lists
        field_splitter = QSplitter(Qt.Orientation.Horizontal)
        field_splitter.setChildrenCollapsible(False)
        
        # Available fields container
        available_container = QWidget()
        available_container.setStyleSheet("background-color: rgba(245, 236, 220, 0.5);")
        available_layout = QVBoxLayout(available_container)
        available_layout.setContentsMargins(0, 0, 0, 0)
        available_layout.setSpacing(4)
        
        available_label = QLabel("Available Fields")
        available_label.setStyleSheet("font-weight: bold; color: #333333;")
        available_layout.addWidget(available_label)
        
        self.available_list = QListWidget()
        self.available_list.addItems(["Show", "Scene", "Take", "Category", "Subcategory", "Slate", "ixmlNote", "ixmlWildtrack", "ixmlCircled"])
        self.available_list.setSelectionMode(QListWidget.SelectionMode.ExtendedSelection)
        self.available_list.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        available_layout.addWidget(self.available_list)
        
        field_splitter.addWidget(available_container)
        
        # Buttons container - vertical in center
        buttons_container = QWidget()
        buttons_container.setStyleSheet("background-color: rgba(245, 236, 220, 0.5);")
        buttons_container.setFixedWidth(40)
        buttons_layout = QVBoxLayout(buttons_container)
        buttons_layout.setContentsMargins(4, 0, 4, 0)
        buttons_layout.setSpacing(8)
        buttons_layout.addStretch()
        
        add_button = QPushButton("â†’")
        add_button.setFixedSize(32, 32)
        add_button.clicked.connect(self.add_fields)
        buttons_layout.addWidget(add_button)
        
        remove_button = QPushButton("â†")
        remove_button.setFixedSize(32, 32)
        remove_button.clicked.connect(self.remove_fields)
        buttons_layout.addWidget(remove_button)
        
        buttons_layout.addSpacing(20)
        
        up_button = QPushButton("â†‘")
        up_button.setFixedSize(32, 32)
        up_button.clicked.connect(self.move_field_up)
        buttons_layout.addWidget(up_button)
        
        down_button = QPushButton("â†“")
        down_button.setFixedSize(32, 32)
        down_button.clicked.connect(self.move_field_down)
        buttons_layout.addWidget(down_button)
        
        buttons_layout.addStretch()
        
        field_splitter.addWidget(buttons_container)
        
        # Selected fields container
        selected_container = QWidget()
        selected_container.setStyleSheet("background-color: rgba(245, 236, 220, 0.5);")
        selected_layout = QVBoxLayout(selected_container)
        selected_layout.setContentsMargins(0, 0, 0, 0)
        selected_layout.setSpacing(4)
        
        selected_label = QLabel("Selected Order")
        selected_label.setStyleSheet("font-weight: bold; color: #333333;")
        selected_layout.addWidget(selected_label)
        
        self.selected_list = QListWidget()
        self.selected_list.setSelectionMode(QListWidget.SelectionMode.ExtendedSelection)
        self.selected_list.setSizePolicy(QSizePolicy.Policy.Expanding, QSizePolicy.Policy.Expanding)
        selected_layout.addWidget(self.selected_list)
        
        field_splitter.addWidget(selected_container)
        
        # Set splitter sizes equally
        field_splitter.setSizes([100, 40, 100])
        
        custom_org_layout.addWidget(field_splitter, 1)  # Give this section more stretch
        
        # Preview section - simplified
        preview_container = QWidget()
        preview_container.setStyleSheet("background-color: rgba(245, 236, 220, 0.5);")
        preview_layout = QVBoxLayout(preview_container)
        preview_layout.setContentsMargins(0, 8, 0, 0)
        preview_layout.setSpacing(4)
        
        preview_label = QLabel("Preview")
        preview_label.setStyleSheet("font-weight: bold; color: #333333;")
        preview_layout.addWidget(preview_label)
        
        self.example_text = QLabel("Select fields to see example folder structure")
        self.example_text.setStyleSheet("font-family: monospace; color: #333333; background-color: rgba(229, 220, 200, 0.7); padding: 8px; border-radius: 4px;")
        self.example_text.setWordWrap(True)
        self.example_text.setMinimumHeight(60)
        preview_layout.addWidget(self.example_text)
        
        custom_org_layout.addWidget(preview_container)
        
        # Options and mirror button - at bottom
        options_layout = QHBoxLayout()
        options_layout.setContentsMargins(0, 4, 0, 0)
        
        self.overwrite_checkbox = QCheckBox("Overwrite existing files")
        self.overwrite_checkbox.setStyleSheet("color: #333333;")
        options_layout.addWidget(self.overwrite_checkbox)
        options_layout.addStretch()
        
        custom_org_layout.addLayout(options_layout)
        
        custom_mirror_button = QPushButton("Mirror with Custom Organization")
        custom_mirror_button.clicked.connect(self.mirror_with_custom_org)
        custom_org_layout.addWidget(custom_mirror_button)
        
        content_layout.addWidget(custom_org_container, 1)  # Give more stretch to this section
        
        # Add content widget to scroll area
        scroll_area.setWidget(content_widget)
        main_layout.addWidget(scroll_area)
        
        # Connect signals for preview updates
        self.selected_list.model().rowsInserted.connect(self.update_preview)
        self.selected_list.model().rowsRemoved.connect(self.update_preview)
        self.selected_list.model().layoutChanged.connect(self.update_preview)
    
    def set_selected_rows(self, selected_rows):
        """Set the selected rows from parent"""
        self.selected_rows = selected_rows
        self.update_selected_count()
        
    def update_selected_count(self):
        """Update the text showing how many files are selected"""
        count = len(self.selected_rows) if self.selected_rows else 0
        if count == 0:
            self.file_count_label.setText("No files selected. Select files in the main panel.")
            self.file_count_label.setStyleSheet("color: #FF3B30; font-weight: bold; font-style: italic;")
        else:
            self.file_count_label.setText(f"{count} file{'s' if count != 1 else ''} selected")
            self.file_count_label.setStyleSheet("color: #007AFF; font-weight: bold;")
            
    def get_selected_rows_from_parent(self):
        """Get currently selected rows from parent, updating our cached selection"""
        if hasattr(self.parent, 'get_selected_actual_rows') and hasattr(self.parent, 'all_files'):
            if not self.parent.all_files:
                QMessageBox.warning(self, "No Files Loaded", 
                                  "Please load WAV files using the Browse button before mirroring.")
                return []
                
            selected_rows = self.parent.get_selected_actual_rows()
            if selected_rows:
                # Update our cached selection
                self.selected_rows = selected_rows
                self.update_selected_count()
            return selected_rows if selected_rows else self.selected_rows
        return self.selected_rows
    
    def close_panel(self):
        """Close the panel using the parent's toggle method"""
        if hasattr(self.parent, 'toggle_mirror_panel'):
            self.parent.toggle_mirror_panel()
    
    def browse_destination(self):
        """Browse for destination directory"""
        folder_path = QFileDialog.getExistingDirectory(self, "Select Destination Folder")
        if folder_path:
            self.dest_input.setText(folder_path)
            self.destination_dir = folder_path
    
    def mirror_for_qcode(self):
        """Mirror files in QCODE Take Review format"""
        # Check if files are selected
        selected_rows = self.get_selected_rows_from_parent()
        if not selected_rows:
            QMessageBox.warning(self, "No Selection", "Please select files in the main panel to mirror.")
            return
            
        dest_dir = self.dest_input.text()
        if not dest_dir:
            QMessageBox.warning(self, "No Destination", "Please select a destination folder.")
            return
            
        day_number = self.day_spinner.value()
        overwrite = self.overwrite_checkbox.isChecked()
        
        # Call the parent's mirror method
        self.parent.mirror_files_qcode_take_review(selected_rows, dest_dir, day_number, overwrite)
    
    def mirror_with_custom_org(self):
        """Mirror files with custom organization"""
        # Check if files are selected
        selected_rows = self.get_selected_rows_from_parent()
        if not selected_rows:
            QMessageBox.warning(self, "No Selection", "Please select files in the main panel to mirror.")
            return
            
        dest_dir = self.dest_input.text()
        if not dest_dir:
            QMessageBox.warning(self, "No Destination", "Please select a destination folder.")
            return
            
        # Gather the selected fields in order
        organization = []
        for i in range(self.selected_list.count()):
            organization.append(self.selected_list.item(i).text())
            
        if not organization:
            QMessageBox.warning(self, "No Organization", "Please select at least one field for folder organization.")
            return
            
        overwrite = self.overwrite_checkbox.isChecked()
        
        # Call the parent's mirror method
        self.parent.mirror_files(selected_rows, dest_dir, organization, overwrite)
    
    def add_fields(self):
        """Add selected fields from available to selected"""
        for item in self.available_list.selectedItems():
            # Create a new item to add to selected list
            new_item = item.text()
            self.selected_list.addItem(new_item)
            
            # Remove from available list
            self.available_list.takeItem(self.available_list.row(item))
    
    def remove_fields(self):
        """Remove selected fields from selected to available"""
        for item in self.selected_list.selectedItems():
            # Create a new item to add back to available list
            new_item = item.text()
            self.available_list.addItem(new_item)
            
            # Remove from selected list
            self.selected_list.takeItem(self.selected_list.row(item))
    
    def move_field_up(self):
        """Move selected field up in the list"""
        current_row = self.selected_list.currentRow()
        if current_row > 0:
            current_item = self.selected_list.takeItem(current_row)
            self.selected_list.insertItem(current_row - 1, current_item)
            self.selected_list.setCurrentRow(current_row - 1)
    
    def move_field_down(self):
        """Move selected field down in the list"""
        current_row = self.selected_list.currentRow()
        if current_row < self.selected_list.count() - 1:
            current_item = self.selected_list.takeItem(current_row)
            self.selected_list.insertItem(current_row + 1, current_item)
            self.selected_list.setCurrentRow(current_row + 1)
    
    def update_preview(self):
        """Update the preview of folder structure"""
        if self.selected_list.count() == 0:
            self.example_text.setText("Select fields to see example folder structure")
            return
            
        # Build example structure
        structure = "destination/"
        for i in range(self.selected_list.count()):
            field = self.selected_list.item(i).text()
            structure += f"<{field}>/"
            
        # Add example values for clearer visualization
        example = structure.replace("<Show>", "<Show: PR2>")
        example = example.replace("<Scene>", "<Scene: 2.14B>")
        example = example.replace("<Take>", "<Take: 03>")
        example = example.replace("<Category>", "<Category: Andre>")
        example = example.replace("<Subcategory>", "<Subcategory: 2>")
        
        self.example_text.setText(example)
    
    def fade_in_widget(self, widget, duration=300):
        """Fade in animation for widgets in the panel"""
        if not self.parent.animations_enabled:
            widget.show()
            return
            
        widget.setAutoFillBackground(True)
        
        # Setup palette for transparency animation
        p = widget.palette()
        p.setColor(QPalette.ColorRole.Window, QColor(0, 0, 0, 0))
        widget.setPalette(p)
        
        # Create opacity effect
        widget.setStyleSheet("background-color: transparent;")
        
        # Show widget first
        widget.show()
        
        # Create animation
        geo = widget.geometry()
        start_rect = QRect(geo.x() + 20, geo.y(), geo.width(), geo.height())
        end_rect = geo
        
        anim = QPropertyAnimation(widget, b"geometry")
        anim.setDuration(duration)
        anim.setStartValue(start_rect)
        anim.setEndValue(end_rect)
        anim.setEasingCurve(QEasingCurve.Type.OutCubic)
        anim.start()
        
        # Restore widget styling after animation
        def restore_style():
            widget.setStyleSheet("")
            
        anim.finished.connect(restore_style)
        
    def update_scene_column(self, index):
        """Update the scene column selection"""
        if hasattr(self, 'csv_headers') and 0 <= index < len(self.csv_headers):
            self.scene_column = self.csv_headers[index]
            self.update_entry_match_display()
    
    def update_take_column(self, index):
        """Update the take column selection"""
        if hasattr(self, 'csv_headers') and 0 <= index < len(self.csv_headers):
            self.take_column = self.csv_headers[index]
            self.update_entry_match_display()

class CSVMatchWizard(QDialog):
    """Wizard for matching CSV data to WAV files in steps"""
    def __init__(self, parent=None):
        super().__init__(parent)
        self.parent = parent
        self.setWindowTitle("Match CSV Data to Audio Files")
        self.resize(800, 600)
        
        # Initialize variables
        self.csv_file_path = ""
        self.csv_data = []
        self.csv_headers = []
        self.character_matches = {}  # Maps audio character to CSV character
        self.field_mappings = {}     # Maps CSV field names to audio metadata fields
        self.character_column = ""   # CSV column that contains character names
        self.scene_column = ""       # CSV column for scene matching
        self.take_column = ""        # CSV column for take matching
        self.current_step = 0        # Track the current step
        
        # Setup UI
        self.setup_ui()
    
    def setup_ui(self):
        """Set up the wizard UI with a stacked widget for steps"""
        main_layout = QVBoxLayout(self)
        main_layout.setContentsMargins(16, 16, 16, 16)
        main_layout.setSpacing(12)
        
        # Set dialog background and styling
        self.setStyleSheet("""
            QDialog {
                background-color: rgba(245, 236, 220, 0.92);
            }
            QLabel {
                color: #333333;
            }
            QPushButton {
                background-color: rgba(245, 236, 220, 0.75);
                color: #333333;
                border: 1px solid rgba(224, 216, 201, 0.7);
                border-radius: 4px;
                padding: 5px 10px;
                min-height: 20px;
            }
            QPushButton:hover {
                background-color: rgba(232, 223, 208, 0.85);
            }
            QPushButton.primary {
                background-color: rgba(196, 181, 159, 0.85);
                color: white;
                border: none;
            }
            QPushButton.primary:hover {
                background-color: rgba(181, 167, 144, 0.95);
            }
            QGroupBox {
                background-color: rgba(245, 236, 220, 0.6);
                border: 1px solid rgba(224, 216, 201, 0.7);
                border-radius: 4px;
                margin-top: 12px;
                font-weight: bold;
                color: #333333;
            }
            QGroupBox::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px 0 5px;
                color: #333333;
            }
            QListWidget {
                background-color: rgba(255, 255, 255, 0.8);
                border: 1px solid rgba(224, 216, 201, 0.7);
                color: #333333;
            }
            QComboBox, QLineEdit {
                padding: 5px;
                border: 1px solid rgba(224, 216, 201, 0.7);
                border-radius: 4px;
                background-color: rgba(255, 255, 255, 0.8);
                color: #333333;
            }
            QCheckBox {
                color: #333333;
            }
        """)
        
        # Page navigation - Step labels at the top
        self.step_layout = QHBoxLayout()
        
        # Step 1: Select CSV File and Match Characters
        self.step1_label = QLabel("1. Match Characters")
        self.step1_label.setStyleSheet("font-weight: bold; color: #333333; padding: 5px; border: 1px solid rgba(224, 216, 201, 0.7); background-color: rgba(245, 236, 220, 0.85);")
        self.step_layout.addWidget(self.step1_label)
        
        # Step 2: Match Entries
        self.step2_label = QLabel("2. Match Entries")
        self.step2_label.setStyleSheet("font-weight: normal; color: #666666; padding: 5px; border: 1px solid rgba(224, 216, 201, 0.7);")
        self.step_layout.addWidget(self.step2_label)
        
        # Step 3: Map Fields
        self.step3_label = QLabel("3. Map Fields")
        self.step3_label.setStyleSheet("font-weight: normal; color: #666666; padding: 5px; border: 1px solid rgba(224, 216, 201, 0.7);")
        self.step_layout.addWidget(self.step3_label)
        
        main_layout.addLayout(self.step_layout)
        
        # Stacked widget to hold the different pages/steps
        self.stack = QStackedWidget()
        main_layout.addWidget(self.stack, 1)  # 1 = stretch factor
        
        # Create pages for each step
        self.page1 = self.create_character_match_page()
        self.page2 = self.create_entry_match_page()
        self.page3 = self.create_field_mapping_page()
        
        # Add pages to stack
        self.stack.addWidget(self.page1)
        self.stack.addWidget(self.page2)
        self.stack.addWidget(self.page3)
        
        # Navigation buttons
        button_layout = QHBoxLayout()
        button_layout.addStretch()
        
        self.back_button = QPushButton("Back")
        self.back_button.setFixedWidth(100)
        self.back_button.clicked.connect(self.go_back)
        self.back_button.setEnabled(False)  # Disabled on first page
        button_layout.addWidget(self.back_button)
        
        self.next_button = QPushButton("Next")
        self.next_button.setFixedWidth(100)
        self.next_button.setProperty("class", "primary")
        self.next_button.clicked.connect(self.go_next)
        button_layout.addWidget(self.next_button)
        
        self.finish_button = QPushButton("Finish")
        self.finish_button.setFixedWidth(100)
        self.finish_button.setProperty("class", "primary")
        self.finish_button.clicked.connect(self.accept)
        self.finish_button.setVisible(False)  # Only visible on last page
        button_layout.addWidget(self.finish_button)
        
        self.cancel_button = QPushButton("Cancel")
        self.cancel_button.setFixedWidth(100)
        self.cancel_button.clicked.connect(self.reject)
        button_layout.addWidget(self.cancel_button)
        
        main_layout.addLayout(button_layout)
        
        # Initialize the first page
        self.update_step_display()

    def create_character_match_page(self):
        """Create the character matching page (Step 1)"""
        page = QWidget()
        layout = QVBoxLayout(page)
        
        # CSV file selection
        csv_file_group = QGroupBox("CSV File")
        csv_file_layout = QHBoxLayout(csv_file_group)
        csv_file_layout.setContentsMargins(10, 16, 10, 10)
        
        self.csv_file_input = QLineEdit()
        self.csv_file_input.setPlaceholderText("Select CSV file...")
        self.csv_file_input.setReadOnly(True)
        csv_file_layout.addWidget(self.csv_file_input)
        
        browse_button = QPushButton("Browse...")
        browse_button.setFixedWidth(100)
        browse_button.clicked.connect(self.browse_csv_file)
        csv_file_layout.addWidget(browse_button)
        
        layout.addWidget(csv_file_group)
        
        # Character matching section
        character_match_group = QGroupBox("Character Matching")
        character_match_layout = QVBoxLayout(character_match_group)
        character_match_layout.setContentsMargins(10, 20, 10, 10)
        
        # Auto-match explanation
        auto_match_label = QLabel("Characters with similar names will be auto-matched. Audio file names in camelCase will match if the first part matches the CSV character name.")
        auto_match_label.setWordWrap(True)
        auto_match_label.setStyleSheet("font-style: italic; color: #666666; font-size: 12px;")
        character_match_layout.addWidget(auto_match_label)
        
        # Add search filter
        search_layout = QHBoxLayout()
        search_label = QLabel("Search:")
        search_label.setStyleSheet("font-weight: bold;")
        search_layout.addWidget(search_label)
        
        self.character_search_input = QLineEdit()
        self.character_search_input.setPlaceholderText("Filter characters...")
        self.character_search_input.setClearButtonEnabled(True)
        self.character_search_input.textChanged.connect(self.filter_character_lists)
        search_layout.addWidget(self.character_search_input)
        
        character_match_layout.addLayout(search_layout)
        
        # Instructions for using double-click
        double_click_label = QLabel("Double-click on a character to match it, or double-click a match to remove it.")
        double_click_label.setStyleSheet("font-style: italic; color: #666666; font-size: 12px;")
        character_match_layout.addWidget(double_click_label)
        
        # Character matching interface
        matching_layout = QHBoxLayout()
        
        # Audio characters list
        audio_char_container = QWidget()
        audio_char_layout = QVBoxLayout(audio_char_container)
        audio_char_layout.setContentsMargins(0, 0, 0, 0)
        
        audio_char_label = QLabel("Unmatched Audio Characters:")
        audio_char_label.setStyleSheet("font-weight: bold;")
        audio_char_layout.addWidget(audio_char_label)
        
        self.audio_char_list = QListWidget()
        self.audio_char_list.setSelectionMode(QListWidget.SelectionMode.SingleSelection)
        self.audio_char_list.itemDoubleClicked.connect(self.on_audio_char_double_clicked)
        audio_char_layout.addWidget(self.audio_char_list)
        
        matching_layout.addWidget(audio_char_container)
        
        # Buttons for matching
        buttons_container = QWidget()
        buttons_layout = QVBoxLayout(buttons_container)
        buttons_layout.setContentsMargins(8, 0, 8, 0)
        buttons_layout.addStretch()
        
        self.match_button = QPushButton("Match â†’")
        self.match_button.clicked.connect(self.match_selected_characters)
        buttons_layout.addWidget(self.match_button)
        
        self.unmatch_button = QPushButton("â† Unmatch")
        self.unmatch_button.clicked.connect(self.unmatch_selected_character)
        buttons_layout.addWidget(self.unmatch_button)
        
        buttons_layout.addStretch()
        
        matching_layout.addWidget(buttons_container)
        
        # CSV characters list
        csv_char_container = QWidget()
        csv_char_layout = QVBoxLayout(csv_char_container)
        csv_char_layout.setContentsMargins(0, 0, 0, 0)
        
        csv_char_label = QLabel("Unmatched CSV Characters:")
        csv_char_label.setStyleSheet("font-weight: bold;")
        csv_char_layout.addWidget(csv_char_label)
        
        self.csv_char_list = QListWidget()
        self.csv_char_list.setSelectionMode(QListWidget.SelectionMode.SingleSelection)
        self.csv_char_list.itemDoubleClicked.connect(self.on_csv_char_double_clicked)
        csv_char_layout.addWidget(self.csv_char_list)
        
        matching_layout.addWidget(csv_char_container)
        
        # Matched pairs list
        matches_container = QWidget()
        matches_layout = QVBoxLayout(matches_container)
        matches_layout.setContentsMargins(0, 0, 0, 0)
        
        matches_label = QLabel("Current Matches:")
        matches_label.setStyleSheet("font-weight: bold;")
        matches_layout.addWidget(matches_label)
        
        self.matches_list = QListWidget()
        self.matches_list.setSelectionMode(QListWidget.SelectionMode.SingleSelection)
        self.matches_list.itemDoubleClicked.connect(self.on_match_double_clicked)
        matches_layout.addWidget(self.matches_list)
        
        matching_layout.addWidget(matches_container)
        
        character_match_layout.addLayout(matching_layout)
        
        # Auto-match button
        auto_match_button = QPushButton("Auto-Match All")
        auto_match_button.clicked.connect(self.auto_match_characters)
        character_match_layout.addWidget(auto_match_button)
        
        layout.addWidget(character_match_group, 1)
        
        return page

    def filter_character_lists(self):
        """Filter all character lists based on search input"""
        search_text = self.character_search_input.text().lower()
        
        # Store current selections
        audio_current = self.audio_char_list.currentItem()
        audio_current_text = audio_current.text() if audio_current else ""
        
        csv_current = self.csv_char_list.currentItem()
        csv_current_text = csv_current.text() if csv_current else ""
        
        matches_current = self.matches_list.currentItem()
        matches_current_text = matches_current.text() if matches_current else ""
        
        # Make sure lists are up to date before filtering
        # This ensures we have _all_unmatched_audio_chars and _all_unmatched_csv_chars
        self.update_audio_character_list()
        self.update_csv_character_list()
        
        # 1. Filter Audio characters list
        self.audio_char_list.clear()
        if hasattr(self, '_all_unmatched_audio_chars'):
            for character in self._all_unmatched_audio_chars:
                if not search_text or search_text in character.lower():
                    self.audio_char_list.addItem(character)
                    
            # Restore selection if possible
            if audio_current_text:
                for i in range(self.audio_char_list.count()):
                    if self.audio_char_list.item(i).text() == audio_current_text:
                        self.audio_char_list.setCurrentRow(i)
                        break
        
        # 2. Filter CSV characters list
        self.csv_char_list.clear()
        if hasattr(self, '_all_unmatched_csv_chars'):
            for character in self._all_unmatched_csv_chars:
                if not search_text or search_text in character.lower():
                    self.csv_char_list.addItem(character)
                    
            # Restore selection if possible
            if csv_current_text:
                for i in range(self.csv_char_list.count()):
                    if self.csv_char_list.item(i).text() == csv_current_text:
                        self.csv_char_list.setCurrentRow(i)
                        break
        
        # 3. Filter Matches list
        self.matches_list.clear()
        sorted_matches = sorted(self.character_matches.items(), key=lambda x: x[0])
        for audio_char, csv_char in sorted_matches:
            match_text = f"{audio_char} â†’ {csv_char}"
            if not search_text or search_text in audio_char.lower() or search_text in csv_char.lower():
                self.matches_list.addItem(match_text)
                
        # Restore selection if possible
        if matches_current_text:
            for i in range(self.matches_list.count()):
                if self.matches_list.item(i).text() == matches_current_text:
                    self.matches_list.setCurrentRow(i)
                    break
    
    def update_character_lists(self):
        """Update both character lists to reflect current matches"""
        # Store search text to reapply filter
        search_text = ""
        if hasattr(self, 'character_search_input'):
            search_text = self.character_search_input.text()
            
        # First update the raw lists
        self.update_audio_character_list()
        self.update_csv_character_list()
        
        # Then apply the search filter if there's any search text
        if search_text:
            self.filter_character_lists()
            
    def update_matches_list(self):
        """Update the list of matched character pairs"""
        # Store search text and current selection to reapply
        search_text = ""
        if hasattr(self, 'character_search_input'):
            search_text = self.character_search_input.text()
            
        current_item = self.matches_list.currentItem()
        current_text = current_item.text() if current_item else ""
        
        # Clear and update the list
        self.matches_list.clear()
        
        # Sort matches alphabetically by audio character name
        sorted_matches = sorted(self.character_matches.items(), key=lambda x: x[0])
        
        # Add all items if no search, or only matching items if searching
        for audio_char, csv_char in sorted_matches:
            match_text = f"{audio_char} â†’ {csv_char}"
            if not search_text or search_text.lower() in audio_char.lower() or search_text.lower() in csv_char.lower():
                self.matches_list.addItem(match_text)
                
        # Restore previous selection if possible
        if current_text:
            for i in range(self.matches_list.count()):
                if self.matches_list.item(i).text() == current_text:
                    self.matches_list.setCurrentRow(i)
                    break
    
    def auto_match_characters(self):
        """Automatically match characters with the same name or closest match"""
        if not self.csv_data or not self.character_column:
            return
            
        try:
            # Get all available audio characters
            audio_characters = set()
            for file_path, metadata in self.parent.all_files:
                character = metadata.get("Category", "")
                if character:
                    audio_characters.add(character)
            
            # Get all available CSV characters
            char_col_idx = self.csv_headers.index(self.character_column)
            csv_characters = set()
            for row in self.csv_data:
                if char_col_idx < len(row) and row[char_col_idx]:
                    csv_characters.add(row[char_col_idx])
            
            # Track which CSV characters are already matched to ensure 1-to-1 matching
            matched_csv_chars = set(self.character_matches.values())
            available_csv_chars = csv_characters - matched_csv_chars
            
            # Store all candidate matches with scores for later processing
            all_potential_matches = []
            
            # First pass: gather all potential matches with scores
            for audio_char in audio_characters:
                if audio_char not in self.character_matches:
                    # Extract any numbers from the end of the audio character name
                    audio_number_match = re.search(r'(\d+)$', audio_char)
                    audio_number = audio_number_match.group(1) if audio_number_match else None
                    
                    # Try exact match first (case-insensitive)
                    exact_matches = [c for c in available_csv_chars if c.lower() == audio_char.lower()]
                    if exact_matches:
                        all_potential_matches.append((audio_char, exact_matches[0], 200))  # Perfect match gets highest score
                        continue
                    
                    # Special handling for numbered characters
                    if audio_number:
                        # Look for CSV characters with the same base name and matching number
                        audio_base = audio_char[:audio_number_match.start()]
                        for csv_char in available_csv_chars:
                            csv_lower = csv_char.lower()
                            
                            # Look for "#number" pattern in CSV character
                            csv_number_match = re.search(r'#(\d+)', csv_char)
                            if csv_number_match and csv_number_match.group(1) == audio_number:
                                # Check if the base name also matches
                                csv_base = csv_lower.split('#')[0].strip()
                                if audio_base.lower() in csv_base or csv_base in audio_base.lower():
                                    all_potential_matches.append((audio_char, csv_char, 150))  # High score for number match
                            
                            # Also check for plain numbers at the end of CSV character
                            csv_plain_number_match = re.search(r'(\d+)$', csv_lower)
                            if csv_plain_number_match and csv_plain_number_match.group(1) == audio_number:
                                # Check if the base name also matches
                                csv_base = csv_lower[:csv_plain_number_match.start()].strip()
                                if audio_base.lower() in csv_base or csv_base in audio_base.lower():
                                    all_potential_matches.append((audio_char, csv_char, 140))  # Good score for number match
                    
                    # Split audio character into words
                    audio_words = re.findall(r'[A-Z]?[a-z]+|\d+', audio_char)  # Split camelCase into words
                    audio_words_lower = [w.lower() for w in audio_words]
                    
                    # Handle word-based matching
                    for csv_char in available_csv_chars:
                        csv_lower = csv_char.lower()
                        
                        # Score based on word matching
                        score = 0
                        
                        # If character already got a numbered match, skip word matching
                        if any(match[0] == audio_char and match[2] >= 140 for match in all_potential_matches):
                            continue
                        
                        # Check for exact word matches, regardless of order
                        csv_words = csv_lower.split()
                        matching_words = set(audio_words_lower) & set(csv_words)
                        
                        # Calculate percentage of matching words
                        if matching_words:
                            # More weight to exact word matches
                            match_percentage = len(matching_words) / max(len(audio_words_lower), len(csv_words))
                            score += int(match_percentage * 60)  # Up to 60 points for word matches
                            
                            # Bonus if first word matches - often indicates character type
                            if audio_words_lower and csv_words and audio_words_lower[0] == csv_words[0]:
                                score += 20
                            
                            # Extra bonus for full word-for-word match, regardless of case/order
                            if len(matching_words) == len(audio_words_lower) == len(csv_words):
                                score += 50
                        
                        # Check for subword/substring matches if no exact word matches
                        if not matching_words:
                            # Check if audio character appears as substring in CSV
                            if ''.join(audio_words_lower) in csv_lower.replace(' ', ''):
                                score += 15
                            
                            # Check if CSV character appears as substring in audio
                            elif csv_lower.replace(' ', '') in ''.join(audio_words_lower):
                                score += 10
                                
                            # Individual word substring check
                            else:
                                for aw in audio_words_lower:
                                    if any(aw in cw or cw in aw for cw in csv_words):
                                        score += 5
                        
                        # Add to potential matches if score is positive
                        if score > 0:
                            all_potential_matches.append((audio_char, csv_char, score))
            
            # Sort all potential matches by score (highest first)
            all_potential_matches.sort(key=lambda x: x[2], reverse=True)
            
            # Debug: Print potential matches
            print("Potential matches (sorted by score):")
            for audio_char, csv_char, score in all_potential_matches:
                print(f"  {audio_char} â†’ {csv_char} (score: {score})")
            
            # Second pass: apply matches ensuring 1-to-1 relationship
            matched_csv_chars = set()  # Track which CSV chars are already used
            matched_audio_chars = set()  # Track which audio chars are already matched
            
            for audio_char, csv_char, score in all_potential_matches:
                # Skip if audio char already matched (from previous matches)
                if audio_char in self.character_matches or audio_char in matched_audio_chars:
                    continue
                    
                # Skip if csv char already matched
                if csv_char in matched_csv_chars:
                    continue
                    
                # Apply the match
                self.character_matches[audio_char] = csv_char
                matched_csv_chars.add(csv_char)
                matched_audio_chars.add(audio_char)
            
            # Update the lists
            self.update_matches_list()
            self.update_character_lists()
            
            # Show a message about the results
            matched_count = len(self.character_matches)
            QMessageBox.information(
                self, 
                "Auto-Match Results", 
                f"Matched {matched_count} characters with a one-to-one relationship.\n\n"
                f"Each CSV character is now matched to at most one audio character."
            )
            
        except Exception as e:
            print(f"Error auto-matching characters: {e}")
            QMessageBox.warning(self, "Error", f"Error auto-matching characters: {e}")
            
    def load_csv_data(self):
        """Load data from the selected CSV file"""
        import csv
        
        try:
            with open(self.csv_file_path, 'r', newline='', encoding='utf-8-sig') as csvfile:
                reader = csv.reader(csvfile)
                self.csv_headers = next(reader)  # Get headers
                self.csv_data = list(reader)      # Get all data rows
            
            # Try to detect character, scene and take columns based on name
            for i, header in enumerate(self.csv_headers):
                lower_header = header.lower()
                if 'character' in lower_header or 'actor' in lower_header or 'talent' in lower_header:
                    self.character_column = header
                elif 'scene' in lower_header:
                    self.scene_column = header
                elif 'take' in lower_header:
                    self.take_column = header
            
            # Reset existing matches when loading a new CSV
            self.character_matches = {}
            
            # Update character lists with unmatched items
            self.update_character_lists()
            
            # Try auto-matching characters
            self.auto_match_characters()
            
            # Success message
            QMessageBox.information(self, "CSV Loaded", f"Successfully loaded CSV with {len(self.csv_data)} rows.")
            
        except Exception as e:
            QMessageBox.critical(self, "Error Loading CSV", f"Failed to load CSV file: {e}")
            
    def validate_current_step(self):
        """Validate the current step before allowing to proceed"""
        if self.current_step == 0:  # Character matching
            # Check if CSV file is loaded
            if not self.csv_data:
                QMessageBox.warning(self, "No CSV File", "Please select a CSV file first.")
                return False
                
            # Check if character column is selected
            if not self.character_column:
                QMessageBox.warning(self, "Missing Column", "Please select a character column in the CSV file.")
                return False
                
            # Check if any characters are matched
            if not self.character_matches:
                QMessageBox.warning(self, "No Matches", "Please match at least one character before continuing.")
                return False
                
            return True
        
        elif self.current_step == 1:  # Entry matching
            # Check if scene column is selected
            if not self.scene_column:
                QMessageBox.warning(self, "Missing Column", "Please select a scene column in the CSV file.")
                return False
                
            # Check if take column is selected
            if not self.take_column:
                QMessageBox.warning(self, "Missing Column", "Please select a take column in the CSV file.")
                return False
            
            # Check if we have potential matches
            try:
                char_col_idx = self.csv_headers.index(self.character_column)
                scene_col_idx = self.csv_headers.index(self.scene_column)
                take_col_idx = self.csv_headers.index(self.take_column)
                
                # Build a lookup of available CSV entries
                csv_entries = {}
                for row in self.csv_data:
                    if max(char_col_idx, scene_col_idx, take_col_idx) < len(row):
                        char = row[char_col_idx]
                        scene = row[scene_col_idx]
                        take = row[take_col_idx]
                        
                        # Build a key for lookup
                        key = (char, scene, take)
                        csv_entries[key] = True
                
                # Check which audio files would match
                matched_count = 0
                
                if hasattr(self.parent, 'all_files'):
                    for file_path, metadata in self.parent.all_files:
                        audio_char = metadata.get("Category", "")
                        if not audio_char or audio_char not in self.character_matches:
                            continue
                        
                        csv_char = self.character_matches[audio_char]
                        audio_scene = metadata.get("Scene", "")
                        audio_take = metadata.get("Take", "")
                        
                        if audio_scene and audio_take:
                            # Check exact match
                            key = (csv_char, audio_scene, audio_take)
                            if key in csv_entries:
                                matched_count += 1
                            elif self.partial_scene_check.isChecked():
                                # Try partial match if enabled
                                for csv_key in csv_entries.keys():
                                    csv_char_match, csv_scene, csv_take = csv_key
                                    
                                    if csv_char_match != csv_char:
                                        continue
                                    
                                    # Check if take matches (with or without case sensitivity)
                                    if self.case_sensitive_check.isChecked():
                                        # Case sensitive comparison
                                        if csv_take != audio_take:
                                            continue
                                    else:
                                        # Case insensitive comparison
                                        if csv_take.lower() != audio_take.lower():
                                            continue
                                    
                                    # Check if scene partially matches (with or without case sensitivity)
                                    if self.case_sensitive_check.isChecked():
                                        # Case sensitive comparison
                                        if csv_scene and audio_scene.startswith(csv_scene):
                                            matched_count += 1
                                            break
                                    else:
                                        # Case insensitive comparison
                                        if csv_scene and audio_scene.lower().startswith(csv_scene.lower()):
                                            matched_count += 1
                                            break
                
                if matched_count == 0:
                    result = QMessageBox.question(
                        self, 
                        "No Matches Found", 
                        "No matches were found with the current settings. Would you like to continue anyway?",
                        QMessageBox.StandardButton.Yes | QMessageBox.StandardButton.No
                    )
                    if result == QMessageBox.StandardButton.No:
                        return False
            except Exception as e:
                QMessageBox.warning(self, "Error", f"Error validating matches: {str(e)}")
                return False
            
            return True
            
        return True
    
    def update_step_display(self):
        """Update the step display and button visibility"""
        # Reset all step labels
        self.step1_label.setStyleSheet("font-weight: normal; color: #666666; padding: 5px; border: 1px solid rgba(224, 216, 201, 0.7);")
        self.step2_label.setStyleSheet("font-weight: normal; color: #666666; padding: 5px; border: 1px solid rgba(224, 216, 201, 0.7);")
        self.step3_label.setStyleSheet("font-weight: normal; color: #666666; padding: 5px; border: 1px solid rgba(224, 216, 201, 0.7);")
        
        # Highlight current step
        if self.current_step == 0:
            self.step1_label.setStyleSheet("font-weight: bold; color: #333333; padding: 5px; border: 1px solid rgba(224, 216, 201, 0.7); background-color: rgba(245, 236, 220, 0.85);")
            self.back_button.setEnabled(False)
            self.next_button.setVisible(True)
            self.finish_button.setVisible(False)
        elif self.current_step == 1:
            self.step2_label.setStyleSheet("font-weight: bold; color: #333333; padding: 5px; border: 1px solid rgba(224, 216, 201, 0.7); background-color: rgba(245, 236, 220, 0.85);")
            self.back_button.setEnabled(True)
            self.next_button.setVisible(True)
            self.finish_button.setVisible(False)
        elif self.current_step == 2:
            self.step3_label.setStyleSheet("font-weight: bold; color: #333333; padding: 5px; border: 1px solid rgba(224, 216, 201, 0.7); background-color: rgba(245, 236, 220, 0.85);")
            self.back_button.setEnabled(True)
            self.next_button.setVisible(False)
            self.finish_button.setVisible(True)
    
    def go_back(self):
        """Navigate to the previous step"""
        if self.current_step > 0:
            self.current_step -= 1
            self.stack.setCurrentIndex(self.current_step)
            self.update_step_display()
    
    def go_next(self):
        """Navigate to the next step"""
        # Validate current step
        if not self.validate_current_step():
            return
            
        # Move to next step if validation passed
        if self.current_step < 2:
            self.current_step += 1
            self.stack.setCurrentIndex(self.current_step)
            self.update_step_display()
            
            # Update the appropriate page based on new step
            if self.current_step == 1:
                # Update entry match page
                self.update_entry_match_display()
            elif self.current_step == 2:
                # Update field mapping page
                self.update_mapping_preview()
                
                # Initialize the field mapping controls if not already done
                if not hasattr(self, 'field_mapping_controls') or not self.field_mapping_controls:
                    self.auto_map_fields()
    
    def update_entry_match_display(self):
        """Update the entry match page based on current selections"""
        if not hasattr(self, 'scene_column_combo') or not hasattr(self, 'take_column_combo'):
            return
            
        # Update character column display
        if hasattr(self, 'character_display'):
            self.character_display.setText(self.character_column if hasattr(self, 'character_column') else "")
            
        # Populate scene preview list
        if hasattr(self, 'scene_preview_list'):
            self.scene_preview_list.clear()
            if self.scene_column and self.csv_data:
                try:
                    scene_col_idx = self.csv_headers.index(self.scene_column)
                    scenes = set()
                    for row in self.csv_data:
                        if scene_col_idx < len(row) and row[scene_col_idx]:
                            scenes.add(row[scene_col_idx])
                    
                    for scene in sorted(scenes):
                        self.scene_preview_list.addItem(scene)
                except (ValueError, IndexError):
                    pass
        
        # Populate take preview list
        if hasattr(self, 'take_preview_list'):
            self.take_preview_list.clear()
            if self.take_column and self.csv_data:
                try:
                    take_col_idx = self.csv_headers.index(self.take_column)
                    takes = set()
                    for row in self.csv_data:
                        if take_col_idx < len(row) and row[take_col_idx]:
                            takes.add(row[take_col_idx])
                    
                    for take in sorted(takes):
                        self.take_preview_list.addItem(take)
                except (ValueError, IndexError):
                    pass
        
        # Update match summary
        if hasattr(self, 'match_summary'):
            summary_text = ""
            
            # Get potential matches count
            if self.character_matches and self.scene_column and self.take_column and self.csv_data:
                try:
                    # Get indices for columns
                    char_col_idx = self.csv_headers.index(self.character_column)
                    scene_col_idx = self.csv_headers.index(self.scene_column)
                    take_col_idx = self.csv_headers.index(self.take_column)
                    
                    # Build a lookup of available CSV entries
                    csv_entries = {}
                    for row in self.csv_data:
                        if max(char_col_idx, scene_col_idx, take_col_idx) < len(row):
                            char = row[char_col_idx]
                            scene = row[scene_col_idx]
                            take = row[take_col_idx]
                            
                            # Build a key for lookup
                            key = (char, scene, take)
                            csv_entries[key] = True
                    
                    # Check which audio files would match
                    matched_count = 0
                    total_count = 0
                    matched_chars = set()
                    
                    # Get unique scene and take combinations from audio files
                    audio_scenes = set()
                    audio_takes = set()
                    
                    if hasattr(self.parent, 'all_files'):
                        for file_path, metadata in self.parent.all_files:
                            audio_char = metadata.get("Category", "")
                            if not audio_char:
                                continue
                                
                            total_count += 1
                            
                            # Check if character is matched
                            if audio_char in self.character_matches:
                                csv_char = self.character_matches[audio_char]
                                matched_chars.add(audio_char)
                                
                                # Get scene and take from audio file
                                audio_scene = metadata.get("Scene", "")
                                audio_take = metadata.get("Take", "")
                                
                                if audio_scene and audio_take:
                                    audio_scenes.add(audio_scene)
                                    audio_takes.add(audio_take)
                                    
                                    # Check exact match
                                    key = (csv_char, audio_scene, audio_take)
                                    if key in csv_entries:
                                        matched_count += 1
                                    elif self.partial_scene_check.isChecked():
                                        # Try partial match if enabled
                                        for csv_key in csv_entries.keys():
                                            csv_char_match, csv_scene, csv_take = csv_key
                                            
                                            if csv_char_match != csv_char:
                                                continue
                                            
                                            # Check if take matches (with or without case sensitivity)
                                            if self.case_sensitive_check.isChecked():
                                                # Case sensitive comparison
                                                if csv_take != audio_take:
                                                    continue
                                            else:
                                                # Case insensitive comparison
                                                if csv_take.lower() != audio_take.lower():
                                                    continue
                                            
                                            # Check if scene partially matches (with or without case sensitivity)
                                            if self.case_sensitive_check.isChecked():
                                                # Case sensitive comparison
                                                if csv_scene and audio_scene.startswith(csv_scene):
                                                    matched_count += 1
                                                    break
                                            else:
                                                # Case insensitive comparison
                                                if csv_scene and audio_scene.lower().startswith(csv_scene.lower()):
                                                    matched_count += 1
                                                    break
                    
                    # Build summary
                    summary_text += f"Character matches: {len(self.character_matches)} characters\n"
                    summary_text += f"Audio files with matched characters: {len(matched_chars)} characters\n"
                    summary_text += f"Scene values in audio files: {len(audio_scenes)}\n"
                    summary_text += f"Take values in audio files: {len(audio_takes)}\n\n"
                    
                    if total_count > 0:
                        match_percent = (matched_count / total_count) * 100
                        summary_text += f"Potential matches: {matched_count} of {total_count} files ({match_percent:.1f}%)\n"
                        
                        if matched_count == 0:
                            summary_text += "\nNo matches found. Please check your scene and take column selections."
                        elif matched_count < total_count * 0.5:
                            summary_text += "\nFew matches found. You may want to check your scene and take column selections."
                except Exception as e:
                    summary_text = f"Error generating match summary: {str(e)}"
            else:
                summary_text = "Please select the character, scene, and take columns to see potential matches."
            
            self.match_summary.setText(summary_text)
    
    def browse_csv_file(self):
        """Browse for a CSV file"""
        file_path, _ = QFileDialog.getOpenFileName(
            self, "Select CSV File", "", "CSV Files (*.csv);;All Files (*.*)"
        )
        
        if not file_path:
            return
            
        self.csv_file_path = file_path
        self.csv_file_input.setText(file_path)
        
        # Load CSV data
        self.load_csv_data()
    
    def on_audio_char_double_clicked(self, item):
        """Handle double-click on audio character item"""
        audio_char = item.text()
        
        # Find first unmatched CSV character to match with
        for i in range(self.csv_char_list.count()):
            csv_item = self.csv_char_list.item(i)
            if csv_item:
                csv_char = csv_item.text()
                self.character_matches[audio_char] = csv_char
                self.update_matches_list()
                self.update_character_lists()
                break
    
    def on_csv_char_double_clicked(self, item):
        """Handle double-click on CSV character item"""
        csv_char = item.text()
        
        # Find first unmatched audio character to match with
        for i in range(self.audio_char_list.count()):
            audio_item = self.audio_char_list.item(i)
            if audio_item:
                audio_char = audio_item.text()
                self.character_matches[audio_char] = csv_char
                self.update_matches_list()
                self.update_character_lists()
                break
    
    def on_match_double_clicked(self, item):
        """Handle double-click on a match item to unmatch it"""
        match_text = item.text()
        audio_char = match_text.split(" â†’ ")[0]
        
        # Remove the match
        if audio_char in self.character_matches:
            del self.character_matches[audio_char]
        
        # Update lists
        self.update_matches_list()
        self.update_character_lists()

    def update_audio_character_list(self):
        """Update the list of characters from audio files, showing only unmatched ones"""
        if not hasattr(self.parent, 'all_files') or not self.parent.all_files:
            return
            
        try:
            # Get unique character names (Category field) from audio files
            audio_characters = set()
            for file_path, metadata in self.parent.all_files:
                character = metadata.get("Category", "")
                if character:
                    audio_characters.add(character)
            
            # Get characters that are already matched
            matched_audio_chars = set(self.character_matches.keys())
            
            # Get unmatched characters
            unmatched_audio_chars = audio_characters - matched_audio_chars
            
            # Store these for use in filter_character_lists
            self._all_unmatched_audio_chars = sorted(unmatched_audio_chars)
            
            # If we have a search filter active, don't update the list directly
            if hasattr(self, 'character_search_input') and self.character_search_input.text():
                return
                
            # If no active filter, update the audio character list
            self.audio_char_list.clear()
            for character in self._all_unmatched_audio_chars:
                self.audio_char_list.addItem(character)
        except Exception as e:
            print(f"Error updating audio character list: {e}")
            
    def update_csv_character_list(self):
        """Update the list of characters from the CSV file, showing only unmatched ones"""
        if not self.csv_data or not self.character_column:
            return
            
        try:
            # Get the index of the character column
            char_col_idx = self.csv_headers.index(self.character_column)
            
            # Get unique character names from CSV
            csv_characters = set()
            for row in self.csv_data:
                if char_col_idx < len(row) and row[char_col_idx]:
                    csv_characters.add(row[char_col_idx])
            
            # Get characters that are already matched
            matched_csv_chars = set(self.character_matches.values())
            
            # Get unmatched characters
            unmatched_csv_chars = csv_characters - matched_csv_chars
            
            # Store these for use in filter_character_lists
            self._all_unmatched_csv_chars = sorted(unmatched_csv_chars)
            
            # If we have a search filter active, don't update the list directly
            if hasattr(self, 'character_search_input') and self.character_search_input.text():
                return
                
            # If no active filter, update the CSV character list
            self.csv_char_list.clear()
            for character in self._all_unmatched_csv_chars:
                self.csv_char_list.addItem(character)
        except Exception as e:
            print(f"Error updating CSV character list: {e}")
            
    def match_selected_characters(self):
        """Match the selected characters from both lists"""
        audio_item = self.audio_char_list.currentItem()
        csv_item = self.csv_char_list.currentItem()
        
        if audio_item and csv_item:
            audio_char = audio_item.text()
            csv_char = csv_item.text()
            
            # Create the match
            self.character_matches[audio_char] = csv_char
            
            # Update the lists
            self.update_matches_list()
            self.update_character_lists()
    
    def unmatch_selected_character(self):
        """Remove the selected match"""
        match_item = self.matches_list.currentItem()
        if match_item:
            match_text = match_item.text()
            audio_char = match_text.split(" â†’ ")[0]
            
            # Remove the match
            if audio_char in self.character_matches:
                del self.character_matches[audio_char]
            
            # Update the lists
            self.update_matches_list()
            self.update_character_lists()
    
    def update_matches_list(self):
        """Update the list of matched character pairs"""
        self.matches_list.clear()
        # Sort matches alphabetically by audio character name
        sorted_matches = sorted(self.character_matches.items(), key=lambda x: x[0])
        for audio_char, csv_char in sorted_matches:
            self.matches_list.addItem(f"{audio_char} â†’ {csv_char}")
    
    def create_entry_match_page(self):
        """Create the entry match page where users configure matching by scene and take numbers"""
        page = QWidget()
        layout = QVBoxLayout(page)
        layout.setContentsMargins(10, 10, 10, 10)
        layout.setSpacing(10)
        
        # Instructions
        instructions = QLabel(
            "Configure how CSV entries will be matched to audio files. " +
            "Select which CSV columns contain the scene and take information to match with your audio files."
        )
        instructions.setWordWrap(True)
        instructions.setStyleSheet("font-style: italic; color: #555555;")
        layout.addWidget(instructions)
        
        # Create a scroll area for the content
        scroll_area = QScrollArea()
        scroll_area.setWidgetResizable(True)
        scroll_area.setFrameShape(QFrame.Shape.NoFrame)
        
        # Create container for all content
        scroll_content = QWidget()
        scroll_layout = QVBoxLayout(scroll_content)
        scroll_layout.setContentsMargins(0, 0, 0, 0)
        scroll_layout.setSpacing(12)
        
        # Matching configuration group
        matching_group = QGroupBox("Matching Configuration")
        matching_layout = QVBoxLayout(matching_group)
        matching_layout.setContentsMargins(10, 15, 10, 10)
        
        # Show selected character column (already selected in step 1)
        char_layout = QHBoxLayout()
        char_label = QLabel("Character Column:")
        char_label.setMinimumWidth(120)
        self.character_display = QLineEdit()
        self.character_display.setReadOnly(True)
        self.character_display.setText(self.character_column if hasattr(self, 'character_column') else "")
        char_layout.addWidget(char_label)
        char_layout.addWidget(self.character_display)
        matching_layout.addLayout(char_layout)
        
        # Scene column selection
        scene_layout = QHBoxLayout()
        scene_label = QLabel("Scene Column:")
        scene_label.setMinimumWidth(120)
        self.scene_column_combo = QComboBox()
        if hasattr(self, 'csv_headers'):
            self.scene_column_combo.addItems(self.csv_headers)
            # Try to auto-select column with "scene" in the name
            for i, header in enumerate(self.csv_headers):
                if "scene" in header.lower():
                    self.scene_column_combo.setCurrentIndex(i)
                    self.scene_column = header
                    break
        self.scene_column_combo.currentIndexChanged.connect(lambda idx: self.update_scene_column(idx))
        scene_layout.addWidget(scene_label)
        scene_layout.addWidget(self.scene_column_combo)
        matching_layout.addLayout(scene_layout)
        
        # Take column selection
        take_layout = QHBoxLayout()
        take_label = QLabel("Take Column:")
        take_label.setMinimumWidth(120)
        self.take_column_combo = QComboBox()
        if hasattr(self, 'csv_headers'):
            self.take_column_combo.addItems(self.csv_headers)
            # Try to auto-select column with "take" in the name
            for i, header in enumerate(self.csv_headers):
                if "take" in header.lower():
                    self.take_column_combo.setCurrentIndex(i)
                    self.take_column = header
                    break
        self.take_column_combo.currentIndexChanged.connect(lambda idx: self.update_take_column(idx))
        take_layout.addWidget(take_label)
        take_layout.addWidget(self.take_column_combo)
        matching_layout.addLayout(take_layout)
        
        # Add options for matching flexibility
        matching_options_layout = QVBoxLayout()
        matching_options_layout.setContentsMargins(0, 10, 0, 0)
        
        # Case sensitivity option
        self.case_sensitive_check = QCheckBox("Case sensitive matching")
        self.case_sensitive_check.setChecked(False)
        self.case_sensitive_check.stateChanged.connect(self.update_entry_match_display)
        matching_options_layout.addWidget(self.case_sensitive_check)
        
        # Partial scene matching option
        self.partial_scene_check = QCheckBox("Allow partial scene number matching (e.g., '5.1' matches '5.14D')")
        self.partial_scene_check.setChecked(True)
        self.partial_scene_check.stateChanged.connect(self.update_entry_match_display)
        matching_options_layout.addWidget(self.partial_scene_check)
        
        matching_layout.addLayout(matching_options_layout)
        
        scroll_layout.addWidget(matching_group)
        
        # Preview section
        preview_group = QGroupBox("Column Preview")
        preview_layout = QHBoxLayout(preview_group)
        preview_layout.setContentsMargins(10, 15, 10, 10)
        
        # Scene preview
        scene_preview_container = QWidget()
        scene_preview_layout = QVBoxLayout(scene_preview_container)
        scene_preview_label = QLabel("Scene Values:")
        scene_preview_layout.addWidget(scene_preview_label)
        self.scene_preview_list = QListWidget()
        scene_preview_layout.addWidget(self.scene_preview_list)
        preview_layout.addWidget(scene_preview_container)
        
        # Take preview
        take_preview_container = QWidget()
        take_preview_layout = QVBoxLayout(take_preview_container)
        take_preview_label = QLabel("Take Values:")
        take_preview_layout.addWidget(take_preview_label)
        self.take_preview_list = QListWidget()
        take_preview_layout.addWidget(self.take_preview_list)
        preview_layout.addWidget(take_preview_container)
        
        scroll_layout.addWidget(preview_group)
        
        # Match summary group
        summary_group = QGroupBox("Match Summary")
        summary_layout = QVBoxLayout(summary_group)
        summary_layout.setContentsMargins(10, 15, 10, 10)
        
        self.match_summary = QTextEdit()
        self.match_summary.setReadOnly(True)
        self.match_summary.setMinimumHeight(100)
        self.match_summary.setStyleSheet("background-color: rgba(255, 255, 255, 0.8);")
        summary_layout.addWidget(self.match_summary)
        
        scroll_layout.addWidget(summary_group)
        
        # Set the scroll area widget
        scroll_area.setWidget(scroll_content)
        layout.addWidget(scroll_area)
        
        # Initialize the match display
        QTimer.singleShot(0, self.update_entry_match_display)
        
        return page
    
    def update_scene_column(self, index):
        """Update the scene column selection"""
        if hasattr(self, 'csv_headers') and 0 <= index < len(self.csv_headers):
            self.scene_column = self.csv_headers[index]
            self.update_entry_match_display()
    
    def update_take_column(self, index):
        """Update the take column selection"""
        if hasattr(self, 'csv_headers') and 0 <= index < len(self.csv_headers):
            self.take_column = self.csv_headers[index]
            self.update_entry_match_display()
    
    def update_mapping_preview(self):
        """Update the mapping preview with current selections."""
        # Early return if mapping_preview doesn't exist yet
        if not hasattr(self, 'mapping_preview'):
            return
            
        # Handle QTextEdit (used in field_mapping_page)
        if isinstance(self.mapping_preview, QTextEdit):
            if not hasattr(self, 'csv_headers') or not self.csv_headers:
                self.mapping_preview.setText("No CSV data loaded")
                return
                
            # Get the current mappings
            preview_text = "Character Field: "
            if hasattr(self, 'character_field_combo') and self.character_field_combo.currentIndex() >= 0:
                preview_text += self.csv_headers[self.character_field_combo.currentIndex()]
            else:
                preview_text += "Not selected"
                
            preview_text += "\nScene Field: "
            if hasattr(self, 'scene_field_combo') and self.scene_field_combo.currentIndex() >= 0:
                preview_text += self.csv_headers[self.scene_field_combo.currentIndex()]
            else:
                preview_text += "Not selected"
                
            preview_text += "\nTake Field: "
            if hasattr(self, 'take_field_combo') and self.take_field_combo.currentIndex() >= 0:
                preview_text += self.csv_headers[self.take_field_combo.currentIndex()]
            else:
                preview_text += "Not selected"
                
            # Add additional field mappings
            if hasattr(self, 'field_mapping_list') and self.field_mapping_list.rowCount() > 0:
                preview_text += "\n\nAdditional Field Mappings:"
                for row in range(self.field_mapping_list.rowCount()):
                    csv_combo = self.field_mapping_list.cellWidget(row, 0)
                    meta_combo = self.field_mapping_list.cellWidget(row, 1)
                    
                    if csv_combo and meta_combo:
                        csv_field = csv_combo.currentText()
                        meta_field = meta_combo.currentText()
                        preview_text += f"\n- {csv_field} â†’ {meta_field}"
            
            self.mapping_preview.setText(preview_text)
        
        # Handle QListWidget (used in entry_match_page)
        elif isinstance(self.mapping_preview, QListWidget):
            self.mapping_preview.clear()
        
        # Ensure field_mappings is a dictionary
        if not hasattr(self, 'field_mappings'):
                self.field_mappings = {}
        elif not isinstance(self.field_mappings, dict):
            self.field_mappings = {}
            
        # Update field_mappings from current UI state
        if hasattr(self, 'field_mapping_controls'):
                self.field_mappings.clear()  # Reset mappings
            for csv_field, dropdown, checkbox in self.field_mapping_controls:
                if checkbox.isChecked() and dropdown.currentText():
                    wav_field = dropdown.currentText()
                    self.field_mappings[csv_field] = wav_field
        
        # Display current mappings in the preview
        if self.field_mappings:
                for csv_field, wav_field in self.field_mappings.items():
                item = QListWidgetItem(f"{csv_field} â†’ {wav_field}")
                self.mapping_preview.addItem(item)
        else:
            placeholder = QListWidgetItem("No field mappings defined")
            placeholder.setForeground(QBrush(QColor(150, 150, 150)))  # Gray text
            self.mapping_preview.addItem(placeholder)
            
        # Update title with count
            if hasattr(self.mapping_preview, 'parentWidget') and self.mapping_preview.parentWidget():
        mappings_count = len(self.field_mappings)
        preview_title = f"Mapping Preview ({mappings_count} mappings)"
        self.mapping_preview.parentWidget().setTitle(preview_title)
        
    def auto_map_fields(self):
        """Automatically map fields based on name similarity"""
        if not hasattr(self, 'field_mapping_controls'):
            return
            
        # Build mapping scores for all field combinations
        best_matches = {}
        matched_wav_fields = set()
        
        # First pass: find exact matches and compute similarity scores
        for csv_field, dropdown, checkbox in self.field_mapping_controls:
            csv_field_lower = csv_field.lower()
            best_score = 0
            best_match = ""
            
            for i in range(dropdown.count()):
                wav_field = dropdown.itemText(i)
                if not wav_field:
                    continue
                    
                wav_field_lower = wav_field.lower()
                score = 0
                
                # Exact match gets highest score
                if csv_field_lower == wav_field_lower:
                    score = 100
                # Substring matches get high scores
                elif csv_field_lower in wav_field_lower:
                    score = 75
                elif wav_field_lower in csv_field_lower:
                    score = 70
                # Word matches
                else:
                    # Calculate word similarity
                    csv_words = set(csv_field_lower.split())
                    wav_words = set(wav_field_lower.split())
                    common_words = csv_words.intersection(wav_words)
                    if common_words:
                        score = 50 + 10 * len(common_words)
                    
                    # Character similarity
                    char_overlap = len(set(csv_field_lower) & set(wav_field_lower))
                    score += min(20, char_overlap * 2)
                
                if score > best_score:
                    best_score = score
                    best_match = wav_field
            
            # Store best match if score is high enough
            if best_score >= 30:
                best_matches[csv_field] = (best_match, best_score)
        
        # Second pass: apply mappings in order of confidence (highest scores first)
        sorted_csv_fields = sorted(
            best_matches.keys(),
            key=lambda f: best_matches[f][1],
            reverse=True
        )
        
        # Apply the mappings, ensuring no WAV field is used more than once
        for csv_field in sorted_csv_fields:
            wav_field, score = best_matches[csv_field]
            
            # Skip if this WAV field is already assigned
            if wav_field in matched_wav_fields:
                continue
                
            # Find the controls for this CSV field
            for field, dropdown, checkbox in self.field_mapping_controls:
                if field == csv_field:
                    dropdown.setCurrentText(wav_field)
                    checkbox.setChecked(True)
                    matched_wav_fields.add(wav_field)
                    break
        
        # Update the preview
        self.update_mapping_preview()
        
        # Show success message
        QMessageBox.information(
            self, 
            "Auto-Map Complete", 
            f"Successfully mapped {len(matched_wav_fields)} fields based on name similarity."
        )
    
    def select_all_fields(self):
        """Select all fields for mapping"""
        if hasattr(self, 'field_mapping_controls'):
            for _, _, checkbox in self.field_mapping_controls:
                checkbox.setChecked(True)
            self.update_mapping_preview()
            
    def select_no_fields(self):
        """Deselect all fields for mapping"""
        if hasattr(self, 'field_mapping_controls'):
            for _, _, checkbox in self.field_mapping_controls:
                checkbox.setChecked(False)
            self.update_mapping_preview()

    def create_field_mapping_page(self):
        """Create the field mapping page for step 3."""
        page = QWidget()
        layout = QVBoxLayout(page)
        layout.setContentsMargins(0, 0, 0, 0)
        
        # Instruction label
        instruction_label = QLabel("Step 3: Map CSV fields to metadata fields")
        instruction_label.setProperty("class", "instruction-label")
        
        # CSV field mapping
        mapping_container = QWidget()
        mapping_layout = QVBoxLayout(mapping_container)
        mapping_layout.setContentsMargins(0, 0, 0, 0)
        
        # Field mappings section
        mapping_group = QGroupBox("Field Mappings")
        mapping_group_layout = QVBoxLayout(mapping_group)
        
        # Create a form layout for the mappings
        form_layout = QFormLayout()
        form_layout.setFieldGrowthPolicy(QFormLayout.FieldGrowthPolicy.ExpandingFieldsGrow)
        
        # Dropdown for character field
        self.character_field_combo = QComboBox()
        self.character_field_combo.setMinimumWidth(200)
        form_layout.addRow("Character Field:", self.character_field_combo)
        
        # Dropdown for scene field
        self.scene_field_combo = QComboBox()
        self.scene_field_combo.setMinimumWidth(200)
        form_layout.addRow("Scene Field:", self.scene_field_combo)
        
        # Dropdown for take field
        self.take_field_combo = QComboBox()
        self.take_field_combo.setMinimumWidth(200)
        form_layout.addRow("Take Field:", self.take_field_combo)
        
        # Add the form to the mapping group
        mapping_group_layout.addLayout(form_layout)
        
        # Option list for additional field mappings
        field_mapping_label = QLabel("Additional Field Mappings:")
        
        self.field_mapping_list = QTableWidget(0, 2)
        self.field_mapping_list.setHorizontalHeaderLabels(["CSV Field", "Metadata Field"])
        self.field_mapping_list.horizontalHeader().setSectionResizeMode(0, QHeaderView.ResizeMode.Stretch)
        self.field_mapping_list.horizontalHeader().setSectionResizeMode(1, QHeaderView.ResizeMode.Stretch)
        self.field_mapping_list.setMinimumHeight(150)
        
        # Buttons for field mapping manipulation
        field_btn_container = QWidget()
        field_btn_layout = QHBoxLayout(field_btn_container)
        field_btn_layout.setContentsMargins(0, 0, 0, 0)
        
        add_field_btn = QPushButton("Add Field")
        add_field_btn.setProperty("class", "action-button")
        add_field_btn.clicked.connect(self.add_field_mapping)
        
        remove_field_btn = QPushButton("Remove Field")
        remove_field_btn.setProperty("class", "action-button")
        remove_field_btn.clicked.connect(self.remove_field_mapping)
        
        auto_map_btn = QPushButton("Auto Map")
        auto_map_btn.setProperty("class", "action-button primary")
        auto_map_btn.clicked.connect(self.auto_map_fields)
        
        field_btn_layout.addWidget(add_field_btn)
        field_btn_layout.addWidget(remove_field_btn)
        field_btn_layout.addWidget(auto_map_btn)
        
        mapping_group_layout.addWidget(field_mapping_label)
        mapping_group_layout.addWidget(self.field_mapping_list)
        mapping_group_layout.addWidget(field_btn_container)
        
        # Preview section
        preview_group = QGroupBox("Mapping Preview")
        preview_layout = QVBoxLayout(preview_group)
        
        self.mapping_preview = QTextEdit()
        self.mapping_preview.setReadOnly(True)
        self.mapping_preview.setMinimumHeight(100)
        
        preview_layout.addWidget(self.mapping_preview)
        
        # Add groups to the layout
        mapping_layout.addWidget(mapping_group)
        mapping_layout.addWidget(preview_group)
        
        # Add everything to main layout
        layout.addWidget(instruction_label)
        layout.addWidget(mapping_container)
        
        return page
    
    def add_field_mapping(self):
        """Add a new field mapping row."""
        current_row = self.field_mapping_list.rowCount()
        self.field_mapping_list.insertRow(current_row)
        
        # Create combobox for CSV fields
        csv_combo = QComboBox()
        if self.csv_headers:
            csv_combo.addItems(self.csv_headers)
        
        # Create combobox for metadata fields
        meta_combo = QComboBox()
        meta_fields = ["Show", "Category", "Subcategory", "Slate", "ixmlNote", "ixmlWildtrack", "ixmlCircled"]
        meta_combo.addItems(meta_fields)
        
        # Add widgets to the table
        self.field_mapping_list.setCellWidget(current_row, 0, csv_combo)
        self.field_mapping_list.setCellWidget(current_row, 1, meta_combo)
        
        # Update the preview
        self.update_mapping_preview()
    
    def remove_field_mapping(self):
        """Remove selected field mapping row."""
        selected_rows = self.field_mapping_list.selectedIndexes()
        if not selected_rows:
            return
            
        # Get unique rows (since multiple cells in same row might be selected)
        rows = set()
        for index in selected_rows:
            rows.add(index.row())
            
        # Remove rows in reverse order to avoid index shifting
        for row in sorted(rows, reverse=True):
            self.field_mapping_list.removeRow(row)
            
        # Update the preview
        self.update_mapping_preview()
    
    def auto_map_fields(self):
        """Automatically map fields based on name similarity."""
        # First, clear existing mappings
        while self.field_mapping_list.rowCount() > 0:
            self.field_mapping_list.removeRow(0)
            
        if not self.csv_headers:
            return
            
        # Try to find character field
        character_idx = self.find_best_match(self.csv_headers, ["character", "name", "actor", "talent"])
        if character_idx >= 0:
            self.character_field_combo.setCurrentIndex(character_idx)
            
        # Try to find scene field
        scene_idx = self.find_best_match(self.csv_headers, ["scene", "sc", "scn"])
        if scene_idx >= 0:
            self.scene_field_combo.setCurrentIndex(scene_idx)
            
        # Try to find take field
        take_idx = self.find_best_match(self.csv_headers, ["take", "tk", "takes"])
        if take_idx >= 0:
            self.take_field_combo.setCurrentIndex(take_idx)
            
        # Mapping of metadata fields to possible CSV header matches
        field_matches = {
            "Show": ["show", "program", "series", "title"],
            "Category": ["category", "type", "kind"],
            "Subcategory": ["subcategory", "subtype", "subkind", "episode"],
            "Slate": ["slate", "marker", "circle", "circled"],
            "ixmlNote": ["note", "notes", "comment", "comments", "description"],
            "ixmlWildtrack": ["wild", "wildtrack", "ambient", "room tone"],
            "ixmlCircled": ["circled", "circle", "good", "good take", "best"]
        }
        
        # Find and add matches for additional fields
        for meta_field, keywords in field_matches.items():
            idx = self.find_best_match(self.csv_headers, keywords)
            if idx >= 0:
                # Add this mapping
                current_row = self.field_mapping_list.rowCount()
                self.field_mapping_list.insertRow(current_row)
                
                csv_combo = QComboBox()
                csv_combo.addItems(self.csv_headers)
                csv_combo.setCurrentIndex(idx)
                
                meta_combo = QComboBox()
                meta_fields = ["Show", "Category", "Subcategory", "Slate", "ixmlNote", "ixmlWildtrack", "ixmlCircled"]
                meta_combo.addItems(meta_fields)
                meta_combo.setCurrentIndex(meta_fields.index(meta_field))
                
                self.field_mapping_list.setCellWidget(current_row, 0, csv_combo)
                self.field_mapping_list.setCellWidget(current_row, 1, meta_combo)
        
        # Update the preview
        self.update_mapping_preview()
    
    def find_best_match(self, headers, keywords):
        """Find the best match from headers for any keyword."""
        for idx, header in enumerate(headers):
            header_lower = header.lower()
            for keyword in keywords:
                if keyword.lower() in header_lower:
                    return idx
        return -1
        
    def update_mapping_preview(self):
        """Update the mapping preview with current selections."""
        if not self.csv_headers:
            self.mapping_preview.setText("No CSV data loaded")
            return
            
        # Get the current mappings
        preview_text = "Character Field: "
        if self.character_field_combo.currentIndex() >= 0:
            preview_text += self.csv_headers[self.character_field_combo.currentIndex()]
        else:
            preview_text += "Not selected"
            
        preview_text += "\nScene Field: "
        if self.scene_field_combo.currentIndex() >= 0:
            preview_text += self.csv_headers[self.scene_field_combo.currentIndex()]
        else:
            preview_text += "Not selected"
            
        preview_text += "\nTake Field: "
        if self.take_field_combo.currentIndex() >= 0:
            preview_text += self.csv_headers[self.take_field_combo.currentIndex()]
        else:
            preview_text += "Not selected"
            
        # Add additional field mappings
        if self.field_mapping_list.rowCount() > 0:
            preview_text += "\n\nAdditional Field Mappings:"
            for row in range(self.field_mapping_list.rowCount()):
                csv_combo = self.field_mapping_list.cellWidget(row, 0)
                meta_combo = self.field_mapping_list.cellWidget(row, 1)
                
                if csv_combo and meta_combo:
                    csv_field = csv_combo.currentText()
                    meta_field = meta_combo.currentText()
                    preview_text += f"\n- {csv_field} â†’ {meta_field}"
        
        self.mapping_preview.setText(preview_text)

def main():
    app = QApplication(sys.argv)
    window = AudioMetadataEditor()
    window.show()
    sys.exit(app.exec())

if __name__ == "__main__":
    main() 